<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screenshot Preview</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            margin: 0;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Light Theme Variables (Default) - Snipping Tool Style */
        body {
            --primary-color: #0066cc;
            --primary-hover: #0052a3;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            
            /* Backgrounds */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-content: #f5f5f5;
            
            /* Toolbar - Dark like Windows Snipping Tool */
            --toolbar-bg: #2d2d30;
            --toolbar-text: #ffffff;
            --toolbar-border: #3f3f46;
            --toolbar-hover: #404048;
            --toolbar-active: #007acc;
            
            /* Surfaces */
            --surface: rgba(255, 255, 255, 0.95);
            --surface-elevated: rgba(255, 255, 255, 0.98);
            --surface-hover: rgba(255, 255, 255, 0.85);
            
            /* Text */
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            --text-inverse: #ffffff;
            
            /* Borders */
            --border-color: rgba(0, 0, 0, 0.1);
            --border-strong: rgba(0, 0, 0, 0.2);
            --border-subtle: rgba(0, 0, 0, 0.05);
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            
            /* Status bar */
            --status-bg: #ffffff;
            --status-border: #d1d1d1;
            --status-text: #666666;
            
            /* Image border */
            --image-border: #ffffff;
            
            /* Radius */
            --radius-sm: 0.25rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            
            /* Set background */
            background: var(--bg-primary);
        }

        /* Dark Theme Variables - Snipping Tool Style */
        body[data-theme="dark"] {
            --primary-color: #0078d4;
            --primary-hover: #106ebe;
            --success-color: #34d399;
            --warning-color: #fbbf24;
            --danger-color: #f87171;
            
            /* Backgrounds */
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d30;
            --bg-content: #1e1e1e;
            
            /* Toolbar - Darker in dark theme */
            --toolbar-bg: #1e1e1e;
            --toolbar-text: #ffffff;
            --toolbar-border: #3f3f46;
            --toolbar-hover: #404048;
            --toolbar-active: #0078d4;
            
            /* Surfaces */
            --surface: rgba(30, 30, 30, 0.95);
            --surface-elevated: rgba(30, 30, 30, 0.98);
            --surface-hover: rgba(30, 30, 30, 0.85);
            
            /* Text */
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #64748b;
            --text-inverse: #1e1e1e;
            
            /* Borders */
            --border-color: rgba(255, 255, 255, 0.1);
            --border-strong: rgba(255, 255, 255, 0.2);
            --border-subtle: rgba(255, 255, 255, 0.05);
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.4);
            
            /* Status bar */
            --status-bg: #2d2d30;
            --status-border: #3f3f46;
            --status-text: #ffffff;
            
            /* Image border */
            --image-border: #3f3f46;
            
            /* Set background */
            background: var(--bg-primary);
        }

        /* Windows Snipping Tool style toolbar */
        .top-toolbar {
            background: var(--toolbar-bg);
            border: none;
            border-bottom: 1px solid var(--toolbar-border);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 2px;
            flex-shrink: 0;
            min-height: 48px;
            position: relative;
            z-index: 10;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .toolbar-button {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 3px;
            padding: 6px 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 11px;
            font-weight: 400;
            color: var(--toolbar-text);
            min-width: 56px;
            position: relative;
        }
        
        .toolbar-button:hover {
            background: var(--toolbar-hover);
            border-color: var(--toolbar-border);
        }

        .toolbar-button.active {
            background: var(--toolbar-active);
            border-color: var(--toolbar-active);
            color: white;
        }

        .toolbar-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .toolbar-button.disabled:hover {
            background: var(--toolbar-button);
            border-color: var(--toolbar-border);
            transform: none;
        }
        
        .toolbar-button:active {
            transform: scale(0.98);
        }

        .toolbar-icon {
            font-size: 16px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: var(--toolbar-border);
            margin: 0 4px;
            opacity: 0.8;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        /* Status bar at bottom */
        .status-bar {
            background: var(--status-bg);
            border-top: 1px solid var(--status-border);
            padding: 4px 12px;
            font-size: 11px;
            color: var(--status-text);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            min-height: 28px;
        }

        .status-info {
            display: flex;
            gap: 16px;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-content);
            position: relative;
            overflow: hidden;
            padding: 20px;
        }

        .image-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
            max-height: 100%;
        }

        .screenshot-image {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid var(--image-border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            background: white;
            display: block;
        }

        .annotation-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            background: transparent;
        }

        .annotation-canvas.drawing {
            pointer-events: all;
            cursor: crosshair;
        }
        
        .annotation-canvas.drawing.toolbar-area {
            cursor: default;
            pointer-events: none;
        }
        
        /* Ensure toolbar remains interactive during border mode */
        .top-toolbar {
            position: relative;
            z-index: 1001;
        }

        /* Enhanced loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(79, 70, 229, 0.2);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            box-shadow: var(--shadow-sm);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-4px);
            }
        }

        /* Border tool with integrated color picker */
        .border-tool {
            position: relative;
            display: inline-block;
        }
        
        .border-color-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            width: 10px;
            height: 10px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;
        }
        
        .dropdown-arrow {
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 7px;
            color: var(--toolbar-text);
            opacity: 0.6;
            transition: transform 0.15s ease;
        }
        
        .toolbar-button:hover .dropdown-arrow {
            opacity: 1;
        }
        
        .border-tool.show-dropdown .dropdown-arrow {
            transform: rotate(180deg);
        }

        .color-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface-elevated);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 8px;
            display: none;
            gap: 6px;
            z-index: 1000;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transform: translateX(-50%) translateY(-4px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .color-dropdown.show {
            display: flex;
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }
        
        /* Border color dropdown */
        .border-color-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px;
            display: none;
            gap: 4px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateX(-50%) translateY(-4px) scale(0.95);
            transition: all 0.15s ease;
            grid-template-columns: repeat(6, 1fr);
            min-width: 200px;
        }
        
        .border-color-dropdown.show {
            display: grid;
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }
        
        /* Color option styles for border dropdown */
        .border-color-dropdown .color-option {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .border-color-dropdown .color-option[data-color="#e74c3c"] { background-color: #e74c3c; }
        .border-color-dropdown .color-option[data-color="#3498db"] { background-color: #3498db; }
        .border-color-dropdown .color-option[data-color="#2ecc71"] { background-color: #2ecc71; }
        .border-color-dropdown .color-option[data-color="#f39c12"] { background-color: #f39c12; }
        .border-color-dropdown .color-option[data-color="#9b59b6"] { background-color: #9b59b6; }
        .border-color-dropdown .color-option[data-color="#e67e22"] { background-color: #e67e22; }
        .border-color-dropdown .color-option[data-color="#1abc9c"] { background-color: #1abc9c; }
        .border-color-dropdown .color-option[data-color="#34495e"] { background-color: #34495e; }
        .border-color-dropdown .color-option[data-color="#f1c40f"] { background-color: #f1c40f; }
        .border-color-dropdown .color-option[data-color="#e91e63"] { background-color: #e91e63; }
        .border-color-dropdown .color-option[data-color="#000000"] { background-color: #000000; }
        .border-color-dropdown .color-option[data-color="#ffffff"] { background-color: #ffffff; border: 2px solid rgba(0, 0, 0, 0.3); }
        
        .border-color-dropdown .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border-color: #666;
        }
        
        .border-color-dropdown .color-option.selected {
            border-color: #0066cc;
            border-width: 2px;
            transform: scale(1.05);
        }
        
        .border-color-dropdown .color-option.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }
        
        .border-color-dropdown .color-option[data-color="#ffffff"].selected::after,
        .border-color-dropdown .color-option[data-color="#f1c40f"].selected::after {
            color: black;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
        }

        /* Border width dropdown */
        .border-width-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px;
            display: none;
            grid-template-columns: 1fr;
            gap: 4px;
            min-width: 120px;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .border-width-dropdown.show {
            display: grid;
            opacity: 1;
            animation: fadeIn 0.15s ease-out;
        }
        
        /* Width option styles */
        .border-width-dropdown .width-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 12px;
            font-weight: 500;
        }
        
        .border-width-dropdown .width-option:hover {
            background-color: #f0f0f0;
            transform: scale(1.02);
        }
        
        .border-width-dropdown .width-option.selected {
            background-color: #0066cc;
            color: white;
        }
        
        .border-width-dropdown .width-preview {
            flex: 1;
            background-color: #333;
            border-radius: 1px;
            min-width: 40px;
            transition: background-color 0.15s ease;
        }
        
        .border-width-dropdown .width-option.selected .width-preview {
            background-color: white;
        }
        
        /* Border width indicator */
        .border-width-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 8px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 3px;
            border-radius: 2px;
            line-height: 1;
        }

        /* Font size dropdown */
        .font-size-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px;
            display: none;
            grid-template-columns: 1fr;
            gap: 4px;
            min-width: 120px;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .font-size-dropdown.show {
            display: grid;
            opacity: 1;
            animation: fadeIn 0.15s ease-out;
        }
        
        /* Size option styles */
        .font-size-dropdown .size-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 12px;
            font-weight: 500;
        }
        
        .font-size-dropdown .size-option:hover {
            background-color: #f0f0f0;
            transform: scale(1.02);
        }
        
        .font-size-dropdown .size-option.selected {
            background-color: #0066cc;
            color: white;
        }
        
        .font-size-dropdown .size-preview {
            min-width: 20px;
            text-align: center;
            font-weight: bold;
            transition: color 0.15s ease;
        }
        
        .font-size-dropdown .size-option.selected .size-preview {
            color: white;
        }
        
        /* Font size indicator */
        .font-size-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 8px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 3px;
            border-radius: 2px;
            line-height: 1;
        }

        /* Font family dropdown */
        .font-family-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px;
            display: none;
            grid-template-columns: 1fr;
            gap: 4px;
            min-width: 140px;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .font-family-dropdown.show {
            display: grid;
            opacity: 1;
            animation: fadeIn 0.15s ease-out;
        }
        
        /* Font option styles */
        .font-family-dropdown .font-option {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
        }
        
        .font-family-dropdown .font-option:hover {
            background-color: #f0f0f0;
            transform: scale(1.02);
        }
        
        .font-family-dropdown .font-option.selected {
            background-color: #0066cc;
            color: white;
        }
        
        .font-family-dropdown .font-preview {
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Font family indicator */
        .font-family-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 8px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 3px;
            border-radius: 2px;
            line-height: 1;
            max-width: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Text style group */
        .text-style-group {
            display: flex !important;
            gap: 2px;
            padding: 4px;
            background: var(--toolbar-bg);
            border-radius: 6px;
        }
        
        .text-style-group .toolbar-button {
            min-width: 45px;
            padding: 6px 4px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .text-style-btn.active {
            background: var(--toolbar-active) !important;
            color: white;
            transform: scale(0.95);
        }
        
        .text-style-btn:hover {
            background: var(--toolbar-hover);
        }
        
        /* Text style dropdown */
        .text-style-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            display: none;
            min-width: 140px;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .text-style-dropdown.show {
            display: block;
            opacity: 1;
            animation: fadeIn 0.15s ease-out;
        }
        
        .style-options {
            display: flex;
            flex-direction: row;
            gap: 4px;
        }
        
        .style-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
        }
        
        .style-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }
        
        .style-option.active {
            background-color: #0066cc;
            border-color: #0052a3;
            color: white;
        }
        
        .style-option.active .style-icon {
            color: white;
        }
        
        .style-icon {
            font-size: 16px;
            font-weight: normal;
            min-width: 20px;
            text-align: center;
        }
        
        .style-label {
            font-size: 12px;
            font-weight: 500;
        }
        
        /* Text style indicators */
        .text-style-indicators {
            position: absolute;
            bottom: 0;
            right: 0;
            display: flex;
            gap: 1px;
        }
        
        .style-indicator {
            font-size: 6px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 2px;
            border-radius: 2px;
            line-height: 1;
        }
        
        .bold-indicator {
            font-weight: bold;
        }
        
        .italic-indicator {
            font-style: italic;
        }
        
        .underline-indicator {
            text-decoration: underline;
        }

        /* Shapes Dropdown Styles */
        .shape-indicators {
            position: absolute;
            top: 2px;
            right: 2px;
            display: flex;
            gap: 1px;
        }
        
        .shape-indicator {
            font-size: 6px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 2px;
            border-radius: 2px;
            line-height: 1;
        }

        .shapes-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            padding: 8px;
            width: auto;
            z-index: 1000;
            display: none;
            opacity: 0;
            transform: translateX(-50%) translateY(-4px) scale(0.95);
            transition: all 0.15s ease;
        }

        .shapes-dropdown.show {
            display: block;
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
        }

        .shape-options {
            display: flex;
            flex-direction: row;
            gap: 4px;
        }

        .shape-option {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            color: var(--text-primary);
            min-width: 32px;
            height: 32px;
        }

        .shape-option:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .shape-option.active {
            background-color: #0066cc;
            border-color: #0052a3;
            color: white;
        }

        .shape-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .shape-label {
            font-size: 12px;
            font-weight: 500;
        }

        .opacity-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Text Background Controls */
        .background-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .control-label {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
        }

        .background-toggle {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .background-enable-option {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            user-select: none;
        }
        
        .checkbox-container input {
            margin-right: 6px;
        }
        
        .background-color-options {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            width: 150px;
        }
        
        .background-color-options .color-option {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            border: 1px solid #ccc;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .background-color-options .color-option:hover {
            transform: scale(1.1);
            border-color: #0066cc;
        }
        
        .background-color-options .color-option.selected {
            border-color: #0066cc;
            border-width: 2px;
            transform: scale(1.05);
        }
        
        .background-color-options .color-option.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }
        
        .background-color-options .color-option[data-color="#ffffff"].selected::after,
        .background-color-options .color-option[data-color="#ffff44"].selected::after,
        .background-color-options .color-option[data-color="#ffaa44"].selected::after {
            color: black;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
        }
        
        .background-color-options.disabled .color-option {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .background-color-options.disabled .color-option:hover {
            transform: none;
            border-color: #ccc;
        }

        /* Background tool indicators */
        .color-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .value-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 7px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 2px;
            border-radius: 2px;
            line-height: 1;
        }

        .opacity-slider {
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            cursor: pointer;
        }

        .opacity-value {
            font-size: 11px;
            font-weight: bold;
            color: #333;
            min-width: 30px;
            text-align: right;
        }

        .background-indicator {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 8px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 3px;
            border-radius: 2px;
            line-height: 1;
        }

        .color-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: var(--shadow-sm);
        }
        
        .color-option::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.2s ease;
        }

        .color-option:hover {
            transform: scale(1.15);
            border-color: white;
            box-shadow: var(--shadow-md), 0 0 0 3px rgba(79, 70, 229, 0.2);
        }
        
        .color-option.selected::after {
            transform: translate(-50%, -50%) scale(1);
        }

        .color-option.red { background-color: #e74c3c; }
        .color-option.blue { background-color: #3498db; }
        .color-option.green { background-color: #2ecc71; }
        .color-option.orange { background-color: #f39c12; }
        .color-option.purple { background-color: #9b59b6; }

        /* Enhanced border color indicator */
        .current-color {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }
        
        .current-color:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-md);
        }

        /* Clean status message */
        .status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 400;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            text-align: center;
            white-space: nowrap;
        }

        .status.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Enhanced error state */
        .error {
            color: var(--danger-color);
            text-align: center;
            padding: 24px;
            font-weight: 500;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: var(--radius-lg);
            margin: 20px;
        }


        /* Responsive design */
        @media (max-width: 600px) {
            .toolbar {
                flex-wrap: wrap;
            }
            
            .action-btn {
                flex: 1;
                min-width: auto;
            }
            
            .metadata {
                flex-direction: column;
                gap: 4px;
                text-align: right;
            }
            
            .settings-modal {
                width: 95vw;
                max-height: 95vh;
            }
            
            .settings-header {
                padding: 16px 20px;
            }
            
            .settings-tab-content {
                padding: 20px 16px;
            }
            
            .theme-selector {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <!-- Top toolbar like Windows Snipping Tool -->
    <div class="top-toolbar">
        <!-- Group 1: File Operations -->
        <div class="toolbar-group">
            <button class="toolbar-button" id="saveBtn" title="Save">
                <div class="toolbar-icon" style="color: #4CAF50; font-size: 16px;">💾</div>
                <div>Save</div>
            </button>
            <button class="toolbar-button" id="copyImageBtn" title="Copy">
                <div class="toolbar-icon" style="color: #2196F3; font-size: 16px;">📋</div>
                <div>Copy</div>
            </button>
            <button class="toolbar-button" id="copyPathBtn" title="Copy Path">
                <div class="toolbar-icon" style="font-size: 16px;">📁</div>
                <div>Path</div>
            </button>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <!-- Group 2: Drawing Tools -->
        <div class="toolbar-group">
            <!-- Shapes Tool -->
            <div class="border-tool">
                <button class="toolbar-button" id="shapesBtn" title="Shapes - Draw rectangles, lines, and arrows">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        🔷
                        <div class="shape-indicators">
                            <span class="shape-indicator rect-indicator" id="rectIndicator" style="display: none;">⬜</span>
                            <span class="shape-indicator line-indicator" id="lineIndicator" style="display: none;">📏</span>
                            <span class="shape-indicator arrow-indicator" id="arrowIndicator" style="display: none;">➡️</span>
                        </div>
                    </div>
                    <div>Shapes</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="shapes-dropdown" id="shapesDropdown">
                    <div class="shape-options">
                        <button class="shape-option" id="rectOption" data-shape="rect" title="Rectangle - Draw rectangular borders">
                            <span class="shape-icon">⬜</span>
                        </button>
                        <button class="shape-option" id="lineOption" data-shape="line" title="Line - Draw straight lines">
                            <span class="shape-icon">📏</span>
                        </button>
                        <button class="shape-option" id="arrowOption" data-shape="arrow" title="Arrow - Draw arrows to point to important areas">
                            <span class="shape-icon">➡️</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="border-tool">
                <button class="toolbar-button" id="colorBtn" title="Color - Select drawing color">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        🎨
                        <span class="border-color-indicator" id="borderColorIndicator" style="background-color: #e74c3c;"></span>
                    </div>
                    <div>Color</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="border-color-dropdown" id="borderColorDropdown">
                    <div class="color-option selected" data-color="#e74c3c" title="Red"></div>
                    <div class="color-option" data-color="#3498db" title="Blue"></div>
                    <div class="color-option" data-color="#2ecc71" title="Green"></div>
                    <div class="color-option" data-color="#f39c12" title="Orange"></div>
                    <div class="color-option" data-color="#9b59b6" title="Purple"></div>
                    <div class="color-option" data-color="#e67e22" title="Dark Orange"></div>
                    <div class="color-option" data-color="#1abc9c" title="Teal"></div>
                    <div class="color-option" data-color="#34495e" title="Dark Gray"></div>
                    <div class="color-option" data-color="#f1c40f" title="Yellow"></div>
                    <div class="color-option" data-color="#e91e63" title="Pink"></div>
                    <div class="color-option" data-color="#000000" title="Black"></div>
                    <div class="color-option" data-color="#ffffff" title="White"></div>
                </div>
            </div>
            
            <div class="border-tool">
                <button class="toolbar-button" id="widthBtn" title="Width - Select stroke width">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        ✏️
                        <span class="border-width-indicator" id="borderWidthIndicator">3px</span>
                    </div>
                    <div>Width</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="border-width-dropdown" id="borderWidthDropdown">
                    <div class="width-option" data-width="1" title="Thin - 1px">
                        <div class="width-preview" style="height: 1px;"></div>
                        <span>1px</span>
                    </div>
                    <div class="width-option" data-width="2" title="Light - 2px">
                        <div class="width-preview" style="height: 2px;"></div>
                        <span>2px</span>
                    </div>
                    <div class="width-option selected" data-width="3" title="Normal - 3px">
                        <div class="width-preview" style="height: 3px;"></div>
                        <span>3px</span>
                    </div>
                    <div class="width-option" data-width="5" title="Medium - 5px">
                        <div class="width-preview" style="height: 5px;"></div>
                        <span>5px</span>
                    </div>
                    <div class="width-option" data-width="8" title="Bold - 8px">
                        <div class="width-preview" style="height: 8px;"></div>
                        <span>8px</span>
                    </div>
                    <div class="width-option" data-width="12" title="Extra Bold - 12px">
                        <div class="width-preview" style="height: 12px;"></div>
                        <span>12px</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <!-- Group 3: Text Tools -->
        <div class="toolbar-group">
            <button class="toolbar-button" id="textBtn" title="Text - Add text annotations">
                <div class="toolbar-icon" style="font-size: 16px;">📝</div>
                <div>Text</div>
            </button>
            
            <div class="border-tool">
                <button class="toolbar-button" id="fontSizeBtn" title="Font Size - Select text size">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        🔤
                        <span class="font-size-indicator" id="fontSizeIndicator">16px</span>
                    </div>
                    <div>Size</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="font-size-dropdown" id="fontSizeDropdown">
                    <div class="size-option" data-size="12" title="Small - 12px">
                        <span class="size-preview" style="font-size: 12px;">Aa</span>
                        <span>12px</span>
                    </div>
                    <div class="size-option" data-size="14" title="Normal - 14px">
                        <span class="size-preview" style="font-size: 14px;">Aa</span>
                        <span>14px</span>
                    </div>
                    <div class="size-option selected" data-size="16" title="Medium - 16px">
                        <span class="size-preview" style="font-size: 16px;">Aa</span>
                        <span>16px</span>
                    </div>
                    <div class="size-option" data-size="20" title="Large - 20px">
                        <span class="size-preview" style="font-size: 20px;">Aa</span>
                        <span>20px</span>
                    </div>
                    <div class="size-option" data-size="24" title="Extra Large - 24px">
                        <span class="size-preview" style="font-size: 24px;">Aa</span>
                        <span>24px</span>
                    </div>
                    <div class="size-option" data-size="32" title="Huge - 32px">
                        <span class="size-preview" style="font-size: 32px;">Aa</span>
                        <span>32px</span>
                    </div>
                </div>
            </div>
            
            <!-- Font Family Tool -->
            <div class="border-tool">
                <button class="toolbar-button" id="fontFamilyBtn" title="Font Family - Change text font">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        🔤
                        <span class="font-family-indicator" id="fontFamilyIndicator">Arial</span>
                    </div>
                    <div>Font</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="font-family-dropdown" id="fontFamilyDropdown">
                    <div class="font-option selected" data-font="Arial, sans-serif" data-display="Arial" title="Arial - Clean and readable">
                        <span class="font-preview" style="font-family: Arial, sans-serif;">Arial</span>
                    </div>
                    <div class="font-option" data-font="'Times New Roman', Times, serif" data-display="Times" title="Times New Roman - Classic serif font">
                        <span class="font-preview" style="font-family: 'Times New Roman', Times, serif;">Times</span>
                    </div>
                    <div class="font-option" data-font="'Courier New', Courier, monospace" data-display="Courier" title="Courier New - Monospace font">
                        <span class="font-preview" style="font-family: 'Courier New', Courier, monospace;">Courier</span>
                    </div>
                    <div class="font-option" data-font="Helvetica, Arial, sans-serif" data-display="Helvetica" title="Helvetica - Modern sans-serif">
                        <span class="font-preview" style="font-family: Helvetica, Arial, sans-serif;">Helvetica</span>
                    </div>
                    <div class="font-option" data-font="Georgia, 'Times New Roman', serif" data-display="Georgia" title="Georgia - Elegant serif font">
                        <span class="font-preview" style="font-family: Georgia, 'Times New Roman', serif;">Georgia</span>
                    </div>
                    <div class="font-option" data-font="Verdana, Geneva, sans-serif" data-display="Verdana" title="Verdana - Web-optimized sans-serif">
                        <span class="font-preview" style="font-family: Verdana, Geneva, sans-serif;">Verdana</span>
                    </div>
                </div>
            </div>
            
            <!-- Text Style Tool -->
            <div class="border-tool">
                <button class="toolbar-button" id="textStyleBtn" title="Text Style - Format text (Bold, Italic, Underline)">
                    <div class="toolbar-icon" style="font-size: 16px;">
                        𝐓
                        <div class="text-style-indicators">
                            <span class="style-indicator bold-indicator" id="boldIndicator" style="display: none;">B</span>
                            <span class="style-indicator italic-indicator" id="italicIndicator" style="display: none;">I</span>
                            <span class="style-indicator underline-indicator" id="underlineIndicator" style="display: none;">U</span>
                        </div>
                    </div>
                    <div>Style</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="text-style-dropdown" id="textStyleDropdown">
                    <div class="style-options">
                        <button class="style-option" id="boldOption" data-style="bold" title="Bold - Make text bold">
                            <span class="style-icon" style="font-weight: bold;">B</span>
                        </button>
                        <button class="style-option" id="italicOption" data-style="italic" title="Italic - Make text italic">
                            <span class="style-icon" style="font-style: italic;">I</span>
                        </button>
                        <button class="style-option" id="underlineOption" data-style="underline" title="Underline - Underline text">
                            <span class="style-icon" style="text-decoration: underline;">U</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Background Color Tool -->
            <div class="border-tool">
                <button class="toolbar-button disabled" id="bgColorBtn" title="Background Color - Change text background color" disabled>
                    <div class="toolbar-icon" style="font-size: 16px;">🟫</div>
                    <div style="font-size: 10px;">BG Color</div>
                    <div class="color-indicator" id="bgColorIndicator" style="background: #ffffff;"></div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="border-color-dropdown" id="bgColorDropdown">
                    <div class="dropdown-header">Background Color</div>
                    <div class="background-controls">
                        <div class="background-enable-option">
                            <label class="checkbox-container">
                                <input type="checkbox" id="bgEnableCheckbox">
                                <span class="checkmark"></span>
                                Enable Background
                            </label>
                        </div>
                        <div class="background-color-options">
                            <!-- First Row -->
                            <div class="color-option" data-color="#ff4444" title="Red" style="background: #ff4444;"></div>
                            <div class="color-option" data-color="#4488ff" title="Blue" style="background: #4488ff;"></div>
                            <div class="color-option" data-color="#44ff44" title="Green" style="background: #44ff44;"></div>
                            <div class="color-option" data-color="#ffaa44" title="Orange" style="background: #ffaa44;"></div>
                            <div class="color-option" data-color="#aa44ff" title="Purple" style="background: #aa44ff;"></div>
                            <!-- Second Row -->
                            <div class="color-option" data-color="#44aaaa" title="Teal" style="background: #44aaaa;"></div>
                            <div class="color-option" data-color="#333333" title="Dark Gray" style="background: #333333;"></div>
                            <div class="color-option" data-color="#ffff44" title="Yellow" style="background: #ffff44;"></div>
                            <div class="color-option" data-color="#ff44aa" title="Pink" style="background: #ff44aa;"></div>
                            <div class="color-option" data-color="#000000" title="Black" style="background: #000000;"></div>
                            <!-- Third Row -->
                            <div class="color-option white selected" data-color="#ffffff" title="White" style="background: #ffffff; border: 2px solid #ccc;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Background Opacity Tool -->
            <div class="border-tool">
                <button class="toolbar-button disabled" id="bgOpacityBtn" title="Background Opacity - Adjust transparency" disabled>
                    <div class="toolbar-icon" style="font-size: 16px;">💧</div>
                    <div style="font-size: 10px;">Opacity</div>
                    <div class="value-indicator" id="bgOpacityIndicator">80%</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="border-color-dropdown" id="bgOpacityDropdown">
                    <div class="dropdown-header">Background Opacity</div>
                    <div class="background-controls">
                        <div class="opacity-control">
                            <input type="range" id="backgroundOpacity" class="opacity-slider" min="0" max="100" value="80">
                            <span class="opacity-value" id="opacityValue">80%</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Background Radius Tool -->
            <div class="border-tool">
                <button class="toolbar-button disabled" id="bgRadiusBtn" title="Border Radius - Adjust corner roundness" disabled>
                    <div class="toolbar-icon" style="font-size: 16px;">📐</div>
                    <div style="font-size: 10px;">Radius</div>
                    <div class="value-indicator" id="bgRadiusIndicator">4px</div>
                    <div class="dropdown-arrow">▼</div>
                </button>
                <div class="border-color-dropdown" id="bgRadiusDropdown">
                    <div class="dropdown-header">Border Radius</div>
                    <div class="background-controls">
                        <div class="opacity-control">
                            <input type="range" id="backgroundRadius" class="opacity-slider" min="0" max="20" value="4">
                            <span class="opacity-value" id="radiusValue">4px</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main content area -->
    <div class="main-content">
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Loading screenshot...</div>
        </div>
        <div class="image-wrapper" id="imageWrapper" style="display: none;">
            <img class="screenshot-image" id="screenshotImage" />
            <canvas class="annotation-canvas" id="annotationCanvas"></canvas>
        </div>
        <div class="error" id="error" style="display: none;">
            Failed to load screenshot
        </div>
    </div>

    <!-- Bottom status bar -->
    <div class="status-bar">
        <div class="status-info">
            <span id="dimensions">Loading...</span>
            <span id="fileSize">Loading...</span>
            <span id="timestamp">Loading...</span>
        </div>
        <div id="windowInfo">Loading...</div>
    </div>

    <div class="status" id="status"></div>


    <script>
        let screenshotData = null;
        let drawingMode = null; // 'rect', 'line', 'arrow', 'text', or null
        let currentColor = '#e74c3c';
        let currentStrokeWidth = 3; // Default stroke width in pixels
        let currentFontSize = 16; // Default font size in pixels
        let currentFontFamily = 'Arial, sans-serif'; // Default font family
        let currentBold = false; // Bold text style
        let currentItalic = false; // Italic text style
        let currentUnderline = false; // Underline text style
        let isDrawing = false;
        let startX, startY;
        let drawings = []; // Store all drawings (rects, lines, arrows, text)
        let imageWrapper, canvas, ctx;
        let lastImageRect = null; // Store last known image position for scaling
        
        // Drawing resizing functionality
        let selectedDrawing = null; // Currently selected drawing for resizing
        let resizeMode = null; // 'start', 'end', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'width', 'text-drag', or null
        let isResizing = false;
        let resizeHandleRadius = 6; // Size of resize handles
        let widthResizeMode = false; // Special mode for width-only resizing
        
        // Text dragging variables
        let dragStartX = 0;
        let dragStartY = 0;
        
        // Text annotation functionality
        let activeTextEditor = null; // Currently active text editor
        let activeTextBox = null; // Currently active text box area (for preview)
        let isTypingText = false; // Text input mode flag
        
        
        // Text background buttons state management
        function updateTextBackgroundButtonsState() {
            const isTextSelected = selectedDrawing && selectedDrawing.type === 'text';
            const buttons = [bgColorBtn, bgOpacityBtn, bgRadiusBtn];
            
            buttons.forEach(btn => {
                if (!btn) return;
                
                if (isTextSelected) {
                    btn.disabled = false;
                    btn.classList.remove('disabled');
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                } else {
                    btn.disabled = true;
                    btn.classList.add('disabled');
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
            });
            
            // Update indicators with current values
            if (isTextSelected && selectedDrawing) {
                updateBackgroundIndicators(selectedDrawing);
            }
        }
        
        // Update background indicators with current text values
        function updateBackgroundIndicators(textDrawing) {
            // Update color indicator
            if (bgColorIndicator) {
                const color = textDrawing.backgroundColor || currentBackgroundColor;
                bgColorIndicator.style.background = color;
            }
            
            // Update opacity indicator
            if (bgOpacityIndicator) {
                const opacity = textDrawing.backgroundOpacity || currentBackgroundOpacity;
                bgOpacityIndicator.textContent = opacity + '%';
            }
            
            // Update radius indicator
            if (bgRadiusIndicator) {
                const radius = textDrawing.backgroundRadius || 4;
                bgRadiusIndicator.textContent = radius + 'px';
            }
        }
        
        // Function to update individual dropdown controls with current text settings
        function updateDropdownFromText(textDrawing, dropdown) {
            if (!textDrawing || !dropdown) return;
            
            // Update color dropdown
            if (dropdown === bgColorDropdown) {
                const colorOptions = dropdown.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.color === (textDrawing.backgroundColor || currentBackgroundColor)) {
                        option.classList.add('selected');
                    }
                });
            }
            
            // Update opacity dropdown
            if (dropdown === bgOpacityDropdown) {
                if (backgroundOpacity && opacityValue) {
                    const opacity = textDrawing.backgroundOpacity || currentBackgroundOpacity;
                    backgroundOpacity.value = opacity;
                    opacityValue.textContent = opacity + '%';
                }
            }
            
            // Update radius dropdown
            if (dropdown === bgRadiusDropdown) {
                if (backgroundRadius && radiusValue) {
                    const radius = textDrawing.backgroundRadius || 4;
                    backgroundRadius.value = radius;
                    radiusValue.textContent = radius + 'px';
                }
            }
        }
        
        // Theme management
        let currentTheme = 'system';
        let effectiveTheme = 'light';
        let systemTheme = 'light';

        // DOM elements
        const loading = document.getElementById('loading');
        const screenshotImage = document.getElementById('screenshotImage');
        const error = document.getElementById('error');
        const dimensions = document.getElementById('dimensions');
        const fileSize = document.getElementById('fileSize');
        const timestamp = document.getElementById('timestamp');
        const windowInfo = document.getElementById('windowInfo');
        const status = document.getElementById('status');

        // Action buttons
        const copyImageBtn = document.getElementById('copyImageBtn');
        const copyPathBtn = document.getElementById('copyPathBtn');
        const saveBtn = document.getElementById('saveBtn');
        const shapesBtn = document.getElementById('shapesBtn');
        const shapesDropdown = document.getElementById('shapesDropdown');
        const shapesTool = shapesBtn?.parentElement;
        const textBtn = document.getElementById('textBtn');
        
        // Shape indicators
        const rectIndicator = document.getElementById('rectIndicator');
        const lineIndicator = document.getElementById('lineIndicator');
        const arrowIndicator = document.getElementById('arrowIndicator');
        const colorBtn = document.getElementById('colorBtn');
        const borderTool = document.querySelector('.border-tool');
        const borderColorDropdown = document.getElementById('borderColorDropdown');
        const borderColorIndicator = document.getElementById('borderColorIndicator');
        
        // Width dropdown elements
        const widthBtn = document.getElementById('widthBtn');
        const widthTool = document.querySelectorAll('.border-tool')[1]; // Second border-tool is width tool
        const borderWidthDropdown = document.getElementById('borderWidthDropdown');
        const borderWidthIndicator = document.getElementById('borderWidthIndicator');
        
        // Font size dropdown elements
        const fontSizeBtn = document.getElementById('fontSizeBtn');
        const fontSizeTool = document.querySelector('#fontSizeBtn')?.closest('.border-tool'); // Font size tool container
        const fontSizeDropdown = document.getElementById('fontSizeDropdown');
        const fontSizeIndicator = document.getElementById('fontSizeIndicator');
        
        // Font family dropdown elements
        const fontFamilyBtn = document.getElementById('fontFamilyBtn');
        const fontFamilyTool = document.querySelector('#fontFamilyBtn')?.closest('.border-tool');
        const fontFamilyDropdown = document.getElementById('fontFamilyDropdown');
        const fontFamilyIndicator = document.getElementById('fontFamilyIndicator');
        
        // Text style dropdown elements
        const textStyleBtn = document.getElementById('textStyleBtn');
        const textStyleDropdown = document.getElementById('textStyleDropdown');
        const textStyleTool = textStyleBtn?.closest('.border-tool');
        const boldOption = document.getElementById('boldOption');
        const italicOption = document.getElementById('italicOption');
        const underlineOption = document.getElementById('underlineOption');
        const boldIndicator = document.getElementById('boldIndicator');
        const italicIndicator = document.getElementById('italicIndicator');
        const underlineIndicator = document.getElementById('underlineIndicator');
        
        // Text background control elements - separate tools
        const bgColorBtn = document.getElementById('bgColorBtn');
        const bgOpacityBtn = document.getElementById('bgOpacityBtn');
        const bgRadiusBtn = document.getElementById('bgRadiusBtn');
        
        const bgColorTool = bgColorBtn?.closest('.border-tool');
        const bgOpacityTool = bgOpacityBtn?.closest('.border-tool');
        const bgRadiusTool = bgRadiusBtn?.closest('.border-tool');
        
        const bgColorDropdown = document.getElementById('bgColorDropdown');
        const bgOpacityDropdown = document.getElementById('bgOpacityDropdown');
        const bgRadiusDropdown = document.getElementById('bgRadiusDropdown');
        
        const bgColorIndicator = document.getElementById('bgColorIndicator');
        const bgOpacityIndicator = document.getElementById('bgOpacityIndicator');
        const bgEnableCheckbox = document.getElementById('bgEnableCheckbox');
        const bgRadiusIndicator = document.getElementById('bgRadiusIndicator');
        
        // Ensure background checkbox starts unchecked by default
        if (bgEnableCheckbox) {
            bgEnableCheckbox.checked = false;
            // Also ensure the color options are disabled initially
            const colorOptions = document.querySelector('.background-color-options');
            if (colorOptions) {
                colorOptions.classList.add('disabled');
            }
        }
        
        const backgroundOpacity = document.getElementById('backgroundOpacity');
        const backgroundRadius = document.getElementById('backgroundRadius');
        const opacityValue = document.getElementById('opacityValue');
        const radiusValue = document.getElementById('radiusValue');
        
        // Text background settings
        let currentBackgroundEnabled = false;
        let currentBackgroundColor = '#ffffff';
        let currentBackgroundOpacity = 80;
        
        
        // Removed buttons - keep functions but remove UI references
        // const clearBordersBtn = document.getElementById('clearBordersBtn');
        // const undoBorderBtn = document.getElementById('undoBorderBtn');
        // const themeBtn = document.getElementById('themeBtn');
        // const themeIcon = document.getElementById('themeIcon');
        // const themeText = document.getElementById('themeText');

        // Default shortcuts (can be customized later via system tray settings)
        let customShortcuts = {
            'take-screenshot': 'Ctrl+Shift+S',
            'copy-image': 'Ctrl+C',
            'copy-path': 'Ctrl+Shift+C',
            'save': 'Ctrl+S',
            'toggle-borders': 'Ctrl+B',
            'undo-border': 'Ctrl+Z',
            'increase-width': 'Ctrl+Plus',
            'decrease-width': 'Ctrl+Minus',
            'toggle-theme': 'Ctrl+T',
            'close-window': 'Escape'
        };

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            initializeColorPicker();
            initializeTheme();
            // Initialize canvas early to enable drawing tools
            initializeCanvas();
            // Initialize button states
            updateTextBackgroundButtonsState();
            
            // Initialize background color options as disabled (checkbox is unchecked by default)
            const colorOptions = document.querySelector('.background-color-options');
            if (colorOptions && !bgEnableCheckbox.checked) {
                colorOptions.classList.add('disabled');
            }
        });
        
        function initializeColorPicker() {
            // Set the first color option as selected initially
            const firstColorOption = document.querySelector('.color-option.red');
            if (firstColorOption) {
                firstColorOption.classList.add('selected');
            }
        }

        async function initializeTheme() {
            try {
                // Get current theme info from main process
                const themeInfo = await window.electronAPI.getThemeInfo();
                updateTheme(themeInfo);
            } catch (error) {
                console.error('Failed to initialize theme:', error);
                // Fallback to light theme
                updateTheme({ currentTheme: 'system', effectiveTheme: 'light', systemTheme: 'light' });
            }
        }

        function updateTheme(themeInfo) {
            currentTheme = themeInfo.currentTheme;
            effectiveTheme = themeInfo.effectiveTheme;
            systemTheme = themeInfo.systemTheme;

            // Apply theme to body
            document.body.setAttribute('data-theme', effectiveTheme);

            // Update theme button
            updateThemeButton();
            
        }

        // Theme button UI removed - theme switching still available via Ctrl+T
        function updateThemeButton() {
            // UI elements removed from toolbar
            // const themeMap = {
            //     'light': { icon: '🌙', text: 'Dark', title: 'Switch to Dark Theme' },
            //     'dark': { icon: '☀️', text: 'Light', title: 'Switch to Light Theme' },
            //     'system': { 
            //         icon: '🖥️', 
            //         text: 'Auto', 
            //         title: `Auto Theme (Currently ${effectiveTheme === 'dark' ? 'Dark' : 'Light'})` 
            //     }
            // };
            // const theme = themeMap[currentTheme] || themeMap['system'];
            // themeIcon.textContent = theme.icon;
            // themeText.textContent = theme.text;
            // themeBtn.title = theme.title;
        }

        async function cycleTheme() {
            const themes = ['light', 'dark', 'system'];
            const currentIndex = themes.indexOf(currentTheme);
            const nextTheme = themes[(currentIndex + 1) % themes.length];

            try {
                const result = await window.electronAPI.setTheme(nextTheme);
                if (result.success) {
                    updateTheme(result);
                    showStatus(`🎨 Theme switched to ${nextTheme}`, 'success');
                } else {
                    showStatus('❌ Failed to change theme', 'error');
                }
            } catch (error) {
                console.error('Failed to change theme:', error);
                showStatus('❌ Theme change failed', 'error');
            }
        }


        function setupEventListeners() {
            // Action button events
            copyImageBtn?.addEventListener('click', () => handleAction('copy-image'));
            copyPathBtn?.addEventListener('click', () => handleAction('copy-path'));
            saveBtn?.addEventListener('click', () => handleAction('save'));
            // Shapes dropdown functionality
            shapesBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                shapesTool.classList.toggle('show-dropdown');
                shapesDropdown.classList.toggle('show');
            });
            
            // Handle shape option clicks
            shapesDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.shape-option')) {
                    e.stopPropagation();
                    const shapeOption = e.target.closest('.shape-option');
                    const shapeType = shapeOption.dataset.shape;
                    
                    // Remove active class from all options
                    shapesDropdown.querySelectorAll('.shape-option').forEach(option => {
                        option.classList.remove('active');
                    });
                    
                    // Add active class to selected option
                    shapeOption.classList.add('active');
                    
                    // Hide all indicators first
                    rectIndicator.style.display = 'none';
                    lineIndicator.style.display = 'none';
                    arrowIndicator.style.display = 'none';
                    
                    // Show indicator for selected shape
                    if (shapeType === 'rect') {
                        rectIndicator.style.display = 'block';
                    } else if (shapeType === 'line') {
                        lineIndicator.style.display = 'block';
                    } else if (shapeType === 'arrow') {
                        arrowIndicator.style.display = 'block';
                    }
                    
                    // Set drawing mode
                    setDrawingMode(shapeType);
                    
                    // Hide dropdown
                    shapesTool.classList.remove('show-dropdown');
                    shapesDropdown.classList.remove('show');
                    
                    const shapeNames = {
                        'rect': 'Rectangle',
                        'line': 'Line', 
                        'arrow': 'Arrow'
                    };
                    showStatus(`${shapeNames[shapeType]} mode selected.`);
                }
            });
            textBtn?.addEventListener('click', () => {
                setDrawingMode('text');
            });
            
            // Background Color tool functionality
            bgColorBtn?.addEventListener('click', (e) => {
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    e.stopPropagation();
                    
                    // Close other background dropdowns first
                    bgOpacityTool?.classList.remove('show-dropdown');
                    bgOpacityDropdown?.classList.remove('show');
                    bgRadiusTool?.classList.remove('show-dropdown');
                    bgRadiusDropdown?.classList.remove('show');
                    
                    bgColorTool?.classList.toggle('show-dropdown');
                    bgColorDropdown?.classList.toggle('show');
                    
                    // Update dropdown with current text background settings
                    updateDropdownFromText(selectedDrawing, bgColorDropdown);
                } else {
                    showStatus('Please select a text element first to configure background color.');
                }
            });

            // Background Opacity tool functionality  
            bgOpacityBtn?.addEventListener('click', (e) => {
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    e.stopPropagation();
                    
                    // Close other background dropdowns first
                    bgColorTool?.classList.remove('show-dropdown');
                    bgColorDropdown?.classList.remove('show');
                    bgRadiusTool?.classList.remove('show-dropdown');
                    bgRadiusDropdown?.classList.remove('show');
                    
                    bgOpacityTool?.classList.toggle('show-dropdown');
                    bgOpacityDropdown?.classList.toggle('show');
                    
                    // Update dropdown with current text background settings
                    updateDropdownFromText(selectedDrawing, bgOpacityDropdown);
                } else {
                    showStatus('Please select a text element first to configure background opacity.');
                }
            });

            // Background Radius tool functionality
            bgRadiusBtn?.addEventListener('click', (e) => {
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    e.stopPropagation();
                    
                    // Close other background dropdowns first
                    bgColorTool?.classList.remove('show-dropdown');
                    bgColorDropdown?.classList.remove('show');
                    bgOpacityTool?.classList.remove('show-dropdown');
                    bgOpacityDropdown?.classList.remove('show');
                    
                    bgRadiusTool?.classList.toggle('show-dropdown');
                    bgRadiusDropdown?.classList.toggle('show');
                    
                    // Update dropdown with current text background settings
                    updateDropdownFromText(selectedDrawing, bgRadiusDropdown);
                } else {
                    showStatus('Please select a text element first to configure border radius.');
                }
            });

            // Handle background color selection
            bgColorDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.color-option') && selectedDrawing && selectedDrawing.type === 'text') {
                    e.stopPropagation();
                    
                    // Check if background is enabled
                    if (!bgEnableCheckbox.checked) {
                        showStatus('Enable background first to select colors.');
                        return;
                    }
                    
                    const colorOption = e.target.closest('.color-option');
                    
                    // Remove selected from all color options
                    bgColorDropdown.querySelectorAll('.color-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add selected to clicked option
                    colorOption.classList.add('selected');
                    
                    // Set background properties (only if enabled)
                    selectedDrawing.hasBackground = true;
                    selectedDrawing.backgroundColor = colorOption.dataset.color;
                    selectedDrawing.backgroundOpacity = selectedDrawing.backgroundOpacity || currentBackgroundOpacity;
                    selectedDrawing.backgroundRadius = selectedDrawing.backgroundRadius || 4;
                    selectedDrawing.backgroundPadding = selectedDrawing.backgroundPadding || 8;
                    
                    // Update current settings and indicators
                    currentBackgroundColor = colorOption.dataset.color;
                    updateBackgroundIndicators(selectedDrawing);
                    
                    redrawCanvas();
                    showStatus(`Background color changed to ${colorOption.title.toLowerCase()}.`);
                }
            });

            // Handle opacity slider
            backgroundOpacity?.addEventListener('input', (e) => {
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    const opacity = parseInt(e.target.value);
                    
                    // Auto-enable background and set properties
                    selectedDrawing.hasBackground = true;
                    selectedDrawing.backgroundOpacity = opacity;
                    selectedDrawing.backgroundColor = selectedDrawing.backgroundColor || currentBackgroundColor;
                    selectedDrawing.backgroundRadius = selectedDrawing.backgroundRadius || 4;
                    selectedDrawing.backgroundPadding = selectedDrawing.backgroundPadding || 8;
                    
                    // Update current settings and indicators
                    currentBackgroundOpacity = opacity;
                    opacityValue.textContent = `${opacity}%`;
                    updateBackgroundIndicators(selectedDrawing);
                    
                    redrawCanvas();
                    showStatus(`Background opacity: ${opacity}%`);
                }
            });

            // Handle border radius slider
            backgroundRadius?.addEventListener('input', (e) => {
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    const radius = parseInt(e.target.value);
                    
                    // Auto-enable background and set properties
                    selectedDrawing.hasBackground = true;
                    selectedDrawing.backgroundRadius = radius;
                    selectedDrawing.backgroundColor = selectedDrawing.backgroundColor || currentBackgroundColor;
                    selectedDrawing.backgroundOpacity = selectedDrawing.backgroundOpacity || currentBackgroundOpacity;
                    selectedDrawing.backgroundPadding = selectedDrawing.backgroundPadding || 8;
                    
                    // Update indicators
                    radiusValue.textContent = `${radius}px`;
                    updateBackgroundIndicators(selectedDrawing);
                    
                    redrawCanvas();
                    showStatus(`Border radius: ${radius}px`);
                }
            });
            
            // Color tool functionality
            colorBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                borderTool.classList.toggle('show-dropdown');
                borderColorDropdown.classList.toggle('show');
            });
            
            // Handle color selection in border dropdown
            borderColorDropdown?.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-option')) {
                    e.stopPropagation();
                    
                    // Remove selected from all options
                    borderColorDropdown.querySelectorAll('.color-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add selected to clicked option
                    e.target.classList.add('selected');
                    
                    // Update current color
                    currentColor = e.target.dataset.color;
                    borderColorIndicator.style.backgroundColor = currentColor;
                    
                    // If a text is selected, update its color
                    if (selectedDrawing && selectedDrawing.type === 'text') {
                        selectedDrawing.color = currentColor;
                        redrawCanvas(); // Redraw to show updated text color
                        showStatus(`Text color changed to ${currentColor}.`);
                    } else {
                        showStatus(`Border color changed. Click and drag to draw borders. Press Escape to exit.`);
                    }
                    
                    // Hide dropdown (border mode is already active)
                    borderTool.classList.remove('show-dropdown');
                    borderColorDropdown.classList.remove('show');
                    
                    // Show feedback animation
                    borderColorIndicator.style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        borderColorIndicator.style.transform = 'scale(1)';
                    }, 200);
                }
            });
            
            // Width tool functionality
            widthBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                widthTool.classList.toggle('show-dropdown');
                borderWidthDropdown.classList.toggle('show');
            });
            
            // Handle width selection in border width dropdown
            borderWidthDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.width-option')) {
                    e.stopPropagation();
                    const widthOption = e.target.closest('.width-option');
                    
                    // Remove selected from all options
                    borderWidthDropdown.querySelectorAll('.width-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add selected to clicked option
                    widthOption.classList.add('selected');
                    
                    // Update current stroke width
                    currentStrokeWidth = parseInt(widthOption.dataset.width);
                    borderWidthIndicator.textContent = `${currentStrokeWidth}px`;
                    
                    // Hide dropdown
                    widthTool.classList.remove('show-dropdown');
                    borderWidthDropdown.classList.remove('show');
                    
                    // Show feedback animation
                    borderWidthIndicator.style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        borderWidthIndicator.style.transform = 'scale(1)';
                    }, 200);
                    
                    // Update status to show new width
                    showStatus(`Stroke width changed to ${currentStrokeWidth}px. Click and drag to draw with new width.`);
                }
            });
            
            // Font size tool functionality
            fontSizeBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                fontSizeTool.classList.toggle('show-dropdown');
                fontSizeDropdown.classList.toggle('show');
            });
            
            // Handle font size selection
            fontSizeDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.size-option')) {
                    e.stopPropagation();
                    const sizeOption = e.target.closest('.size-option');
                    
                    // Remove selected from all options
                    fontSizeDropdown.querySelectorAll('.size-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add selected to clicked option
                    sizeOption.classList.add('selected');
                    
                    // Update current font size
                    currentFontSize = parseInt(sizeOption.dataset.size);
                    fontSizeIndicator.textContent = `${currentFontSize}px`;
                    
                    // If a text is selected, update its font size and recalculate dimensions
                    if (selectedDrawing && selectedDrawing.type === 'text') {
                        selectedDrawing.fontSize = currentFontSize;
                        // Recalculate text dimensions with new font size
                        selectedDrawing.width = getTextWidth(selectedDrawing.text, currentFontSize);
                        selectedDrawing.height = getTextHeight(selectedDrawing.text, currentFontSize);
                        redrawCanvas(); // Redraw to show updated text size
                        showStatus(`Text size changed to ${currentFontSize}px.`);
                    } else {
                        showStatus(`Font size changed to ${currentFontSize}px. Click to add text with new size.`);
                    }
                    
                    // Hide dropdown
                    fontSizeTool.classList.remove('show-dropdown');
                    fontSizeDropdown.classList.remove('show');
                    
                    // Show feedback animation
                    fontSizeIndicator.style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        fontSizeIndicator.style.transform = 'scale(1)';
                    }, 200);
                }
            });
            
            // Font family tool functionality
            fontFamilyBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                fontFamilyTool.classList.toggle('show-dropdown');
                fontFamilyDropdown.classList.toggle('show');
            });
            
            // Handle font family selection
            fontFamilyDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.font-option')) {
                    e.stopPropagation();
                    const fontOption = e.target.closest('.font-option');
                    
                    // Remove selected from all options
                    fontFamilyDropdown.querySelectorAll('.font-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Add selected to clicked option
                    fontOption.classList.add('selected');
                    
                    // Update current font family
                    currentFontFamily = fontOption.dataset.font;
                    fontFamilyIndicator.textContent = fontOption.dataset.display;
                    
                    // If a text is selected, update its font family and recalculate dimensions
                    if (selectedDrawing && selectedDrawing.type === 'text') {
                        selectedDrawing.fontFamily = currentFontFamily;
                        // Recalculate text dimensions with new font family
                        selectedDrawing.width = getTextWidth(selectedDrawing.text, selectedDrawing.fontSize, currentFontFamily);
                        selectedDrawing.height = getTextHeight(selectedDrawing.text, selectedDrawing.fontSize);
                        redrawCanvas(); // Redraw to show updated text font
                        showStatus(`Text font changed to ${fontOption.dataset.display}.`);
                    } else {
                        showStatus(`Font changed to ${fontOption.dataset.display}. Click to add text with new font.`);
                    }
                    
                    // Hide dropdown
                    fontFamilyTool.classList.remove('show-dropdown');
                    fontFamilyDropdown.classList.remove('show');
                    
                    // Show feedback animation
                    fontFamilyIndicator.style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        fontFamilyIndicator.style.transform = 'scale(1)';
                    }, 200);
                }
            });
            
            // Text style dropdown functionality
            textStyleBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                textStyleTool.classList.toggle('show-dropdown');
                textStyleDropdown.classList.toggle('show');
            });
            
            // Handle style option clicks
            textStyleDropdown?.addEventListener('click', (e) => {
                if (e.target.closest('.style-option')) {
                    e.stopPropagation();
                    const styleOption = e.target.closest('.style-option');
                    const styleType = styleOption.dataset.style;
                    
                    // Toggle the style
                    if (styleType === 'bold') {
                        currentBold = !currentBold;
                        styleOption.classList.toggle('active', currentBold);
                        boldIndicator.style.display = currentBold ? 'block' : 'none';
                        
                        // Update selected text if any
                        if (selectedDrawing && selectedDrawing.type === 'text') {
                            selectedDrawing.bold = currentBold;
                            redrawCanvas();
                            showStatus(`Text ${currentBold ? 'bolded' : 'unbolded'}.`);
                        } else {
                            showStatus(`Bold ${currentBold ? 'enabled' : 'disabled'}. Click to add text with bold style.`);
                        }
                    } else if (styleType === 'italic') {
                        currentItalic = !currentItalic;
                        styleOption.classList.toggle('active', currentItalic);
                        italicIndicator.style.display = currentItalic ? 'block' : 'none';
                        
                        // Update selected text if any
                        if (selectedDrawing && selectedDrawing.type === 'text') {
                            selectedDrawing.italic = currentItalic;
                            redrawCanvas();
                            showStatus(`Text ${currentItalic ? 'italicized' : 'unitalicized'}.`);
                        } else {
                            showStatus(`Italic ${currentItalic ? 'enabled' : 'disabled'}. Click to add text with italic style.`);
                        }
                    } else if (styleType === 'underline') {
                        currentUnderline = !currentUnderline;
                        styleOption.classList.toggle('active', currentUnderline);
                        underlineIndicator.style.display = currentUnderline ? 'block' : 'none';
                        
                        // Update selected text if any
                        if (selectedDrawing && selectedDrawing.type === 'text') {
                            selectedDrawing.underline = currentUnderline;
                            redrawCanvas();
                            showStatus(`Text ${currentUnderline ? 'underlined' : 'not underlined'}.`);
                        } else {
                            showStatus(`Underline ${currentUnderline ? 'enabled' : 'disabled'}. Click to add text with underline style.`);
                        }
                    }
                }
            });

            // Text Background Controls Event Handlers (moved to overlay menu)
            
            // Background enable checkbox handler
            bgEnableCheckbox?.addEventListener('change', (e) => {
                currentBackgroundEnabled = e.target.checked;
                updateTextBackgroundButtonsState();
                
                // Toggle disabled state of color options
                const colorOptions = document.querySelector('.background-color-options');
                if (colorOptions) {
                    if (currentBackgroundEnabled) {
                        colorOptions.classList.remove('disabled');
                    } else {
                        colorOptions.classList.add('disabled');
                    }
                }
                
                // Update selected text if any
                if (selectedDrawing && selectedDrawing.type === 'text') {
                    selectedDrawing.hasBackground = currentBackgroundEnabled;
                    redrawCanvas();
                    showStatus(`Text background ${currentBackgroundEnabled ? 'enabled' : 'disabled'}.`);
                } else {
                    showStatus(`Background ${currentBackgroundEnabled ? 'enabled' : 'disabled'} for new text.`);
                }
            });

            // Close color dropdown when clicking outside
            document.addEventListener('click', () => {
                borderColorDropdown.classList.remove('show');
            });
            
            // Close all dropdowns when clicking outside of tool dropdowns
            document.addEventListener('click', (e) => {
                
                // Only keep dropdowns open if clicking directly on the tool buttons themselves
                // Close dropdowns when clicking anywhere else, including the canvas/screenshot area
                if (!borderTool?.contains(e.target) && !widthTool?.contains(e.target) && 
                    !fontSizeTool?.contains(e.target) && !fontFamilyTool?.contains(e.target) &&
                    !textStyleTool?.contains(e.target) && !shapesTool?.contains(e.target) &&
                    !bgColorTool?.contains(e.target) && !bgOpacityTool?.contains(e.target) && 
                    !bgRadiusTool?.contains(e.target)) {
                    
                    // Close all dropdowns
                    borderTool?.classList.remove('show-dropdown');
                    borderColorDropdown?.classList.remove('show');
                    widthTool?.classList.remove('show-dropdown');
                    borderWidthDropdown?.classList.remove('show');
                    fontSizeTool?.classList.remove('show-dropdown');
                    fontSizeDropdown?.classList.remove('show');
                    fontFamilyTool?.classList.remove('show-dropdown');
                    fontFamilyDropdown?.classList.remove('show');
                    textStyleTool?.classList.remove('show-dropdown');
                    textStyleDropdown?.classList.remove('show');
                    shapesTool?.classList.remove('show-dropdown');
                    shapesDropdown?.classList.remove('show');
                    
                    // Close background tool dropdowns
                    bgColorTool?.classList.remove('show-dropdown');
                    bgColorDropdown?.classList.remove('show');
                    bgOpacityTool?.classList.remove('show-dropdown');
                    bgOpacityDropdown?.classList.remove('show');
                    bgRadiusTool?.classList.remove('show-dropdown');
                    bgRadiusDropdown?.classList.remove('show');
                }
            });


            // Border controls (now keyboard-only: Ctrl+Z for undo)
            // clearBordersBtn?.addEventListener('click', clearAllBorders);
            // undoBorderBtn?.addEventListener('click', undoLastBorder);

            // Theme button removed (still works via keyboard: Ctrl+T)
            // themeBtn?.addEventListener('click', cycleTheme);

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Handle Escape key specifically for drawing mode or selection
                if (e.key === 'Escape') {
                    e.preventDefault();
                    if (drawingMode) {
                        setDrawingMode(null);
                    } else if (selectedDrawing) {
                        selectedDrawing = null;
                        updateTextBackgroundButtonsState();
                        redrawCanvas();
                        showStatus('Selection cleared.');
                    }
                    return;
                }
                
                // Handle Delete key for selected arrows
                if (e.key === 'Delete' && selectedDrawing) {
                    e.preventDefault();
                    const index = drawings.indexOf(selectedDrawing);
                    if (index > -1) {
                        drawings.splice(index, 1);
                        selectedDrawing = null;
                        updateTextBackgroundButtonsState();
                        redrawCanvas();
                        showStatus('✅ Drawing deleted.', 'success');
                    }
                    return;
                }
                
                const pressedShortcut = getShortcutFromEvent(e);
                
                // Find matching action
                for (const [action, shortcut] of Object.entries(customShortcuts)) {
                    if (pressedShortcut === shortcut) {
                        e.preventDefault();
                        handleShortcutAction(action);
                        break;
                    }
                }
            });
        }

        function getShortcutFromEvent(e) {
            const keys = [];
            if (e.ctrlKey || e.metaKey) keys.push('Ctrl');
            if (e.altKey) keys.push('Alt');
            if (e.shiftKey) keys.push('Shift');
            keys.push(e.key.toUpperCase());
            return keys.join('+');
        }

        function handleShortcutAction(action) {
            switch (action) {
                case 'copy-image':
                    handleAction('copy-image');
                    break;
                case 'copy-path':
                    handleAction('copy-path');
                    break;
                case 'save':
                    handleAction('save');
                    break;
                case 'toggle-borders':
                    // Toggle between rect mode and off
                    if (drawingMode === 'rect') {
                        setDrawingMode(null);
                    } else {
                        setDrawingMode('rect');
                    }
                    break;
                case 'undo-border':
                    undoLastDrawing();
                    break;
                case 'increase-width':
                    adjustStrokeWidth(1);
                    break;
                case 'decrease-width':
                    adjustStrokeWidth(-1);
                    break;
                case 'toggle-theme':
                    cycleTheme();
                    break;
                case 'close-window':
                    if (drawingMode) {
                        setDrawingMode(null);
                    } else {
                        window.electronAPI.closePreview();
                    }
                    break;
            }
        }

        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = 'status show';
            
            // Add type-specific styling
            switch(type) {
                case 'success':
                    status.style.borderColor = 'var(--success-color)';
                    status.style.color = 'var(--success-color)';
                    break;
                case 'error':
                    status.style.borderColor = 'var(--danger-color)';
                    status.style.color = 'var(--danger-color)';
                    break;
                case 'warning':
                    status.style.borderColor = 'var(--warning-color)';
                    status.style.color = 'var(--warning-color)';
                    break;
                default:
                    status.style.borderColor = 'var(--primary-color)';
                    status.style.color = 'var(--text-primary)';
            }
            
            setTimeout(() => {
                status.classList.remove('show');
            }, 3000);
        }

        async function handleAction(action) {
            if (!screenshotData) {
                showStatus('No screenshot data available');
                return;
            }

            try {
                let actionData = {
                    action: action,
                    filePath: screenshotData.filePath
                };

                // If we have drawings and action involves image, include drawing data
                if (drawings.length > 0 && (action === 'copy-image' || action === 'save')) {
                    actionData.borders = await generateImageWithDrawings();
                }

                const result = await window.electronAPI.previewAction(actionData);

                if (result.success) {
                    let statusType = 'success';
                    let statusMessage = result.message;
                    
                    // Add emojis based on action type
                    switch(action) {
                        case 'copy-image':
                            statusMessage = '📋 ' + result.message;
                            break;
                        case 'copy-path':
                            statusMessage = '📁 ' + result.message;
                            break;
                        case 'save':
                            statusMessage = '💾 ' + result.message;
                            break;
                    }
                    
                    showStatus(statusMessage, statusType);
                    
                    // Close preview after successful save action
                    if (action === 'save') {
                        setTimeout(() => {
                            window.electronAPI.closePreview();
                        }, 2000);
                    }
                } else {
                    showStatus('❌ Error: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Action failed:', error);
                showStatus('Action failed: ' + error.message);
            }
        }

        async function generateImageWithDrawings() {
            if (drawings.length === 0) return null;

            // Create a new canvas for compositing the final image with drawings
            const compositeCanvas = document.createElement('canvas');
            const compositeCtx = compositeCanvas.getContext('2d');

            // Set canvas size to match original image
            compositeCanvas.width = screenshotImage.naturalWidth;
            compositeCanvas.height = screenshotImage.naturalHeight;

            // Draw the original image
            compositeCtx.drawImage(screenshotImage, 0, 0);

            // Get image position and scaling to convert window coordinates to image coordinates
            const imageRect = screenshotImage.getBoundingClientRect();
            const scaleX = screenshotImage.naturalWidth / imageRect.width;
            const scaleY = screenshotImage.naturalHeight / imageRect.height;

            // Draw all drawings on the composite image
            drawings.forEach(drawing => {
                compositeCtx.strokeStyle = drawing.color;
                compositeCtx.lineWidth = (drawing.strokeWidth || 3) * Math.min(scaleX, scaleY);
                
                if (drawing.type === 'rect') {
                    // Convert window coordinates to image coordinates
                    const imgX = (drawing.x - imageRect.left) * scaleX;
                    const imgY = (drawing.y - imageRect.top) * scaleY;
                    const imgWidth = drawing.width * scaleX;
                    const imgHeight = drawing.height * scaleY;

                    // Only draw rectangles that intersect with the image area
                    if (imgX < screenshotImage.naturalWidth && imgY < screenshotImage.naturalHeight && 
                        imgX + imgWidth > 0 && imgY + imgHeight > 0) {
                        compositeCtx.strokeRect(
                            Math.max(0, imgX),
                            Math.max(0, imgY),
                            Math.min(imgWidth, screenshotImage.naturalWidth - Math.max(0, imgX)),
                            Math.min(imgHeight, screenshotImage.naturalHeight - Math.max(0, imgY))
                        );
                    }
                } else if (drawing.type === 'line') {
                    // Convert line coordinates to image coordinates
                    const imgX1 = (drawing.x1 - imageRect.left) * scaleX;
                    const imgY1 = (drawing.y1 - imageRect.top) * scaleY;
                    const imgX2 = (drawing.x2 - imageRect.left) * scaleX;
                    const imgY2 = (drawing.y2 - imageRect.top) * scaleY;
                    
                    // Draw line if any part intersects with image
                    compositeCtx.beginPath();
                    compositeCtx.moveTo(imgX1, imgY1);
                    compositeCtx.lineTo(imgX2, imgY2);
                    compositeCtx.stroke();
                } else if (drawing.type === 'arrow') {
                    // Convert arrow coordinates to image coordinates
                    const imgX1 = (drawing.x1 - imageRect.left) * scaleX;
                    const imgY1 = (drawing.y1 - imageRect.top) * scaleY;
                    const imgX2 = (drawing.x2 - imageRect.left) * scaleX;
                    const imgY2 = (drawing.y2 - imageRect.top) * scaleY;
                    
                    // Draw arrow line
                    compositeCtx.beginPath();
                    compositeCtx.moveTo(imgX1, imgY1);
                    compositeCtx.lineTo(imgX2, imgY2);
                    compositeCtx.stroke();
                    
                    // Draw arrow head (scaled appropriately) - REVERSED: at start point
                    const angle = Math.atan2(imgY1 - imgY2, imgX1 - imgX2); // Reversed direction
                    const headLength = 20 * Math.min(scaleX, scaleY); // Scale arrow head size
                    const headAngle = Math.PI / 6; // 30 degrees
                    
                    const headX1 = imgX1 - headLength * Math.cos(angle - headAngle);
                    const headY1 = imgY1 - headLength * Math.sin(angle - headAngle);
                    const headX2 = imgX1 - headLength * Math.cos(angle + headAngle);
                    const headY2 = imgY1 - headLength * Math.sin(angle + headAngle);
                    
                    // Draw filled arrow head at START position
                    compositeCtx.fillStyle = drawing.color;
                    compositeCtx.beginPath();
                    compositeCtx.moveTo(imgX1, imgY1);
                    compositeCtx.lineTo(headX1, headY1);
                    compositeCtx.lineTo(headX2, headY2);
                    compositeCtx.closePath();
                    compositeCtx.fill();
                    compositeCtx.stroke();
                } else if (drawing.type === 'text') {
                    // Convert text coordinates to image coordinates
                    const imgX = (drawing.x - imageRect.left) * scaleX;
                    const imgY = (drawing.y - imageRect.top) * scaleY;
                    
                    // Set up text styling
                    compositeCtx.fillStyle = drawing.color;
                    
                    // Build font string with style modifiers
                    let fontStyle = '';
                    if (drawing.italic) fontStyle += 'italic ';
                    if (drawing.bold) fontStyle += 'bold ';
                    
                    compositeCtx.font = `${fontStyle}${drawing.fontSize * Math.min(scaleX, scaleY)}px ${drawing.fontFamily || 'Arial, sans-serif'}`;
                    compositeCtx.textBaseline = 'top';
                    compositeCtx.textAlign = 'left';
                    
                    // Only draw text that's within image bounds
                    if (imgX >= 0 && imgY >= 0 && 
                        imgX < screenshotImage.naturalWidth && 
                        imgY < screenshotImage.naturalHeight) {
                        
                        const lines = drawing.text.split('\n');
                        const scaledFontSize = drawing.fontSize * Math.min(scaleX, scaleY);
                        
                        // Draw background rectangle if enabled
                        if (drawing.hasBackground) {
                            const textWidth = (drawing.width || 100) * Math.min(scaleX, scaleY);
                            const textHeight = (drawing.height || scaledFontSize) * Math.min(scaleX, scaleY);
                            const padding = (drawing.backgroundPadding || 8) * Math.min(scaleX, scaleY);
                            
                            // Save current state
                            const originalGlobalAlpha = compositeCtx.globalAlpha;
                            
                            // Set background opacity
                            compositeCtx.globalAlpha = (drawing.backgroundOpacity || 80) / 100;
                            
                            // Draw background rectangle
                            compositeCtx.fillStyle = drawing.backgroundColor || '#ffffff';
                            const radius = (drawing.backgroundRadius || 4) * Math.min(scaleX, scaleY);
                            
                            const rectX = imgX - padding;
                            const rectY = imgY - padding;
                            const rectWidth = textWidth + (padding * 2);
                            const rectHeight = textHeight + (padding * 2);
                            
                            if (radius > 0 && compositeCtx.roundRect) {
                                // Draw rounded rectangle
                                compositeCtx.beginPath();
                                compositeCtx.roundRect(rectX, rectY, rectWidth, rectHeight, radius);
                                compositeCtx.fill();
                            } else if (radius > 0) {
                                // Fallback for browsers without roundRect
                                compositeCtx.beginPath();
                                compositeCtx.moveTo(rectX + radius, rectY);
                                compositeCtx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                                compositeCtx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                                compositeCtx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                                compositeCtx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                                compositeCtx.closePath();
                                compositeCtx.fill();
                            } else {
                                // Draw regular rectangle
                                compositeCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
                            }
                            
                            // Restore alpha for text
                            compositeCtx.globalAlpha = originalGlobalAlpha;
                        }
                        
                        // Draw text on top of background
                        compositeCtx.fillStyle = drawing.color;
                        lines.forEach((line, index) => {
                            const lineY = imgY + (index * scaledFontSize * 1.2);
                            compositeCtx.fillText(line, imgX, lineY);
                            
                            // Draw underline if enabled
                            if (drawing.underline) {
                                const lineWidth = compositeCtx.measureText(line).width;
                                const underlineY = lineY + scaledFontSize + 2;
                                compositeCtx.beginPath();
                                compositeCtx.moveTo(imgX, underlineY);
                                compositeCtx.lineTo(imgX + lineWidth, underlineY);
                                compositeCtx.strokeStyle = drawing.color;
                                compositeCtx.lineWidth = Math.max(1, scaledFontSize / 16);
                                compositeCtx.stroke();
                            }
                        });
                    }
                }
            });

            // Convert to base64 data URL
            return compositeCanvas.toDataURL('image/png');
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString();
        }

        async function updateWindowInfo(data) {
            try {
                const openWindows = await window.electronAPI.getOpenWindows();
                const currentWindowId = data.windowId;
                const currentScreenshotId = data.screenshotId;
                
                if (openWindows.length > 1) {
                    windowInfo.textContent = `${currentScreenshotId} (${openWindows.length} open)`;
                    windowInfo.title = `${openWindows.length} preview windows currently open. This is ${currentScreenshotId}.`;
                } else {
                    windowInfo.textContent = currentScreenshotId;
                    windowInfo.title = 'Screenshot ID';
                }
            } catch (error) {
                console.error('Failed to update window info:', error);
                windowInfo.textContent = data.screenshotId || 'Unknown';
            }
        }


        // Listen for screenshot data from main process
        window.electronAPI.onScreenshotData((data) => {
            screenshotData = data;
            loadScreenshot(data);
        });

        // Listen for theme updates from main process
        window.electronAPI.onThemeUpdate((themeData) => {
            updateTheme(themeData);
        });

        async function loadScreenshot(data) {
            try {

                // Update metadata
                dimensions.textContent = `${data.dimensions.width} × ${data.dimensions.height}`;
                fileSize.textContent = formatFileSize(data.fileSize);
                timestamp.textContent = formatTimestamp(data.timestamp);

                // Update window info and show multiple windows count
                await updateWindowInfo(data);

                // Load image
                screenshotImage.src = `file://${data.filePath}`;
                
                screenshotImage.onload = () => {
                    loading.style.display = 'none';
                    document.getElementById('imageWrapper').style.display = 'block';
                    initializeCanvas();
                    // Store initial image position for border scaling
                    setTimeout(() => {
                        lastImageRect = screenshotImage.getBoundingClientRect();
                    }, 100);
                };

                screenshotImage.onerror = () => {
                    loading.style.display = 'none';
                    error.style.display = 'block';
                };

            } catch (err) {
                console.error('Failed to load screenshot:', err);
                loading.style.display = 'none';
                error.style.display = 'block';
            }
        }

        function initializeCanvas() {
            imageWrapper = document.getElementById('imageWrapper');
            canvas = document.getElementById('annotationCanvas');
            
            if (!canvas) return;
            
            ctx = canvas.getContext('2d');
            
            // Set canvas size to match window viewport
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            setupCanvasEvents();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (canvas) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    scaleBordersOnResize();
                    redrawCanvas();
                }
            });
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            
            // Right-click disabled - no automatic color picker
            canvas.addEventListener('contextmenu', (e) => {
                if (drawingMode) {
                    e.preventDefault(); // Prevent default context menu but don't open color picker
                }
            });
            
            // Handle mouse up outside the window
            document.addEventListener('mouseup', stopDrawing);
            document.addEventListener('mouseleave', stopDrawing);
            
            // Handle cursor change in toolbar area and arrow hover feedback
            canvas.addEventListener('mousemove', (e) => {
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                
                // Check if we're in drawing mode
                if (drawingMode) {
                    const toolbar = document.querySelector('.top-toolbar');
                    const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
                    
                    if (mouseY < toolbarHeight) {
                        canvas.classList.add('toolbar-area');
                        // Disable pointer events in toolbar area to allow toolbar interactions
                        canvas.style.pointerEvents = 'none';
                    } else {
                        canvas.classList.remove('toolbar-area');
                        // Re-enable pointer events for drawing area
                        canvas.style.pointerEvents = 'all';
                        
                        // Special cursor handling for all drawing modes
                        if (drawingMode) {
                            // Check if hovering over a resize handle of selected drawing
                            if (selectedDrawing && selectedDrawing.type === drawingMode) {
                                const handleType = getResizeHandleAtPoint(mouseX, mouseY, selectedDrawing);
                                if (handleType) {
                                    // Different cursors for different handle types
                                    if (handleType === 'width' || handleType.startsWith('width-')) {
                                        canvas.style.cursor = 'ew-resize'; // Double-arrow cursor for width adjustment
                                    } else {
                                        canvas.style.cursor = 'pointer'; // Standard pointer for position resize
                                    }
                                    return;
                                }
                            }
                            
                            // Check if hovering over any drawing of the same type for selection feedback
                            const hoveredDrawing = findDrawingAtPoint(mouseX, mouseY);
                            if (hoveredDrawing && hoveredDrawing.type === drawingMode) {
                                canvas.style.cursor = 'pointer';
                                return;
                            }
                        }
                        
                        // Default crosshair cursor in drawing mode
                        canvas.style.cursor = 'crosshair';
                    }
                } else {
                    // Not in drawing mode - handle text selection cursors
                    if (selectedDrawing && selectedDrawing.type === 'text') {
                        // Check if hovering over selected text for drag cursor
                        const textWidth = selectedDrawing.width || 100;
                        const textHeight = selectedDrawing.fontSize || 16;
                        const toolbar = document.querySelector('.top-toolbar');
                        const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
                        const clampedY = Math.max(toolbarHeight, selectedDrawing.y);
                        
                        if (mouseX >= selectedDrawing.x && mouseX <= selectedDrawing.x + textWidth && 
                            mouseY >= clampedY && mouseY <= clampedY + textHeight) {
                            canvas.style.cursor = 'move'; // Move cursor for dragging selected text
                            return;
                        }
                    }
                    
                    // Check if hovering over any text for selection cursor
                    const hoveredDrawing = findDrawingAtPoint(mouseX, mouseY);
                    if (hoveredDrawing && hoveredDrawing.type === 'text') {
                        canvas.style.cursor = 'pointer'; // Pointer cursor for text selection
                        return;
                    }
                    
                    // Default cursor
                    canvas.style.cursor = 'default';
                }
            });
        }

        function setDrawingMode(mode) {
            // Clear previous mode
            shapesBtn?.classList.remove('active');
            textBtn?.classList.remove('active');
            
            // Clear any selected drawings when entering drawing mode
            selectedDrawing = null;
            updateTextBackgroundButtonsState();
            
            // Clear any active text editor when changing modes
            if (activeTextEditor) {
                finishTextEditing();
            }
            
            if (drawingMode === mode) {
                // Toggle off if same mode clicked
                drawingMode = null;
                canvas.classList.remove('drawing');
                canvas.classList.remove('toolbar-area');
                canvas.style.pointerEvents = 'auto'; // Allow interaction with existing elements
                redrawCanvas();
                showStatus('Drawing mode disabled. Click text to select and edit it.');
            } else {
                // Set new drawing mode
                drawingMode = mode;
                canvas.classList.add('drawing');
                canvas.style.pointerEvents = 'all';
                redrawCanvas(); // Redraw to clear selection handles
                
                if (mode === 'rect') {
                    shapesBtn.classList.add('active');
                    showStatus('Rectangle mode active! Click and drag to draw rectangles. Ctrl+Z to undo. Escape to exit.');
                } else if (mode === 'line') {
                    shapesBtn.classList.add('active');
                    showStatus('Line mode active! Click and drag to draw lines. Ctrl+Z to undo. Escape to exit.');
                } else if (mode === 'arrow') {
                    shapesBtn.classList.add('active');
                    showStatus('Arrow mode active! Click where arrow starts, drag to where it points. Ctrl+Z to undo. Escape to exit.');
                } else if (mode === 'text') {
                    textBtn.classList.add('active');
                    showStatus('Text mode active! Click and drag to draw text box area. Ctrl+Enter to confirm text.');
                }
            }
        }

        function startDrawing(e) {
            // Only handle left mouse button (button 0)
            if (e.button !== 0) {
                return;
            }
            
            // If we're currently typing text, don't interfere
            if (isTypingText && activeTextEditor) {
                return;
            }
            
            // Get mouse coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Text mode now uses drag-to-draw like other tools
            // The text editor will be created in stopDrawing after area is drawn
            
            // If we're in any drawing mode, check for existing drawing interaction first
            if (drawingMode) {
                // Special handling for text mode - allow text selection and dragging
                if (drawingMode === 'text') {
                    // First check if clicking on existing text to select/drag it
                    const clickedDrawing = findDrawingAtPoint(mouseX, mouseY);
                    if (clickedDrawing && clickedDrawing.type === 'text') {
                        // Select this text and immediately prepare for dragging
                        selectedDrawing = clickedDrawing;
                        updateTextBackgroundButtonsState();
                        isResizing = true;
                        resizeMode = 'text-drag';
                        // Store initial mouse position for dragging offset
                        dragStartX = mouseX;
                        dragStartY = mouseY;
                        redrawCanvas();
                        showStatus('Text selected. Drag to move or click empty space to draw new text.');
                        return;
                    }
                    
                    // No text clicked or clicking empty space - start drawing new text
                    selectedDrawing = null;
                    updateTextBackgroundButtonsState();
                    redrawCanvas(); // Clear the selection border before starting new text
                    isDrawing = true;
                    
                    // Hide dropdowns
                    if (borderTool.classList.contains('show-dropdown')) {
                        borderTool.classList.remove('show-dropdown');
                        borderColorDropdown.classList.remove('show');
                    }
                    if (widthTool.classList.contains('show-dropdown')) {
                        widthTool.classList.remove('show-dropdown');
                        borderWidthDropdown.classList.remove('show');
                    }
                    if (fontSizeTool.classList.contains('show-dropdown')) {
                        fontSizeTool.classList.remove('show-dropdown');
                        fontSizeDropdown.classList.remove('show');
                    }
                    if (fontFamilyTool.classList.contains('show-dropdown')) {
                        fontFamilyTool.classList.remove('show-dropdown');
                        fontFamilyDropdown.classList.remove('show');
                    }
                    
                    startX = mouseX;
                    startY = mouseY;
                    return;
                }
                
                // For other drawing modes, check for existing drawing interaction
                // Check if clicking on a resize handle of a selected drawing
                if (selectedDrawing && selectedDrawing.type === drawingMode) {
                    const handleType = getResizeHandleAtPoint(mouseX, mouseY, selectedDrawing);
                    if (handleType) {
                        // Start resizing
                        isResizing = true;
                        resizeMode = handleType;
                        return;
                    }
                }
                
                // Check if clicking on a drawing of the same type to select it
                const clickedDrawing = findDrawingAtPoint(mouseX, mouseY);
                if (clickedDrawing && clickedDrawing.type === drawingMode) {
                    // Select the drawing but stay in drawing mode
                    selectedDrawing = clickedDrawing;
                    updateTextBackgroundButtonsState();
                    redrawCanvas();
                    const drawingTypeNames = {
                        'rect': 'Rectangle',
                        'line': 'Line', 
                        'arrow': 'Arrow'
                    };
                    const typeName = drawingTypeNames[drawingMode] || drawingMode;
                    showStatus(`${typeName} selected. Drag handles to resize or click empty space to draw new ${typeName.toLowerCase()}s.`);
                    return;
                } else {
                    // Clicking on empty space - deselect and start drawing new shape
                    selectedDrawing = null;
                    updateTextBackgroundButtonsState();
                    isDrawing = true;
                    
                    // Hide color and width dropdowns when drawing starts
                    if (borderTool.classList.contains('show-dropdown')) {
                        borderTool.classList.remove('show-dropdown');
                        borderColorDropdown.classList.remove('show');
                    }
                    if (widthTool.classList.contains('show-dropdown')) {
                        widthTool.classList.remove('show-dropdown');
                        borderWidthDropdown.classList.remove('show');
                    }
                    
                    startX = mouseX;
                    startY = mouseY;
                    return;
                }
            }
            
            // No drawing mode - handle text selection like Inkscape
            if (!drawingMode) {
                // Check if clicking on existing text to select it
                const clickedDrawing = findDrawingAtPoint(mouseX, mouseY);
                if (clickedDrawing && clickedDrawing.type === 'text') {
                    // Select the text and immediately prepare for dragging
                    selectedDrawing = clickedDrawing;
                    updateTextBackgroundButtonsState();
                    isResizing = true;
                    resizeMode = 'text-drag';
                    // Store initial mouse position for dragging offset
                    dragStartX = mouseX;
                    dragStartY = mouseY;
                    redrawCanvas();
                    showStatus('Text selected. Drag to move or click outside to deselect.');
                    return;
                } else if (selectedDrawing && selectedDrawing.type === 'text') {
                    // Clicking outside selected text - deselect it
                    selectedDrawing = null;
                    updateTextBackgroundButtonsState();
                    redrawCanvas();
                    showStatus('Text deselected.');
                } else {
                    // Clear any selection if clicking on empty space
                    selectedDrawing = null;
                    updateTextBackgroundButtonsState();
                    redrawCanvas();
                }
                return;
            }
            
            isDrawing = true;
            
            // Hide color and width dropdowns when drawing starts
            if (borderTool.classList.contains('show-dropdown')) {
                borderTool.classList.remove('show-dropdown');
                borderColorDropdown.classList.remove('show');
            }
            if (widthTool.classList.contains('show-dropdown')) {
                widthTool.classList.remove('show-dropdown');
                borderWidthDropdown.classList.remove('show');
            }
            if (fontSizeTool.classList.contains('show-dropdown')) {
                fontSizeTool.classList.remove('show-dropdown');
                fontSizeDropdown.classList.remove('show');
            }
            if (fontFamilyTool.classList.contains('show-dropdown')) {
                fontFamilyTool.classList.remove('show-dropdown');
                fontFamilyDropdown.classList.remove('show');
            }
            
            // Use direct window coordinates (canvas is full viewport)
            startX = mouseX;
            startY = mouseY;
        }

        function draw(e) {
            // Only handle drawing if we're actually drawing/resizing (initiated by left-click)
            if (!isDrawing && !isResizing) {
                return;
            }
            
            // Get current mouse position relative to canvas
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            // Handle resizing for all drawing types
            if (isResizing && selectedDrawing) {
                // Get toolbar height to constrain movement
                const toolbar = document.querySelector('.top-toolbar');
                const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
                const constrainedY = Math.max(toolbarHeight, currentY);
                
                if (selectedDrawing.type === 'arrow' || selectedDrawing.type === 'line') {
                    // Linear drawings: resize start/end points or width
                    if (resizeMode === 'start') {
                        selectedDrawing.x1 = currentX;
                        selectedDrawing.y1 = constrainedY;
                    } else if (resizeMode === 'end') {
                        selectedDrawing.x2 = currentX;
                        selectedDrawing.y2 = constrainedY;
                    } else if (resizeMode === 'width') {
                        // Adjust width based on distance from line
                        const midX = (selectedDrawing.x1 + selectedDrawing.x2) / 2;
                        const midY = (selectedDrawing.y1 + selectedDrawing.y2) / 2;
                        const distanceFromLine = Math.sqrt((currentX - midX) ** 2 + (currentY - midY) ** 2);
                        
                        // Map distance to stroke width (clamp between 1 and 20)
                        const newWidth = Math.max(1, Math.min(20, Math.round(distanceFromLine / 10)));
                        selectedDrawing.strokeWidth = newWidth;
                    }
                } else if (selectedDrawing.type === 'rect') {
                    // Rectangle: resize based on which handle is being dragged
                    const originalX = selectedDrawing.x;
                    const originalY = selectedDrawing.y;
                    const originalWidth = selectedDrawing.width;
                    const originalHeight = selectedDrawing.height;
                    
                    if (resizeMode.startsWith('width-')) {
                        // Width resizing for rectangles - adjust stroke width based on mouse distance from edge
                        let distanceFromEdge = 0;
                        if (resizeMode === 'width-left' || resizeMode === 'width-right') {
                            distanceFromEdge = Math.abs(currentX - (originalX + originalWidth / 2));
                        } else if (resizeMode === 'width-top' || resizeMode === 'width-bottom') {
                            distanceFromEdge = Math.abs(constrainedY - (originalY + originalHeight / 2));
                        }
                        
                        // Map distance to stroke width (clamp between 1 and 20)
                        const newWidth = Math.max(1, Math.min(20, Math.round(distanceFromEdge / 15)));
                        selectedDrawing.strokeWidth = newWidth;
                    } else {
                        // Position resizing (corner handles)
                        if (resizeMode === 'top-left') {
                            selectedDrawing.width = originalWidth + (originalX - currentX);
                            selectedDrawing.height = originalHeight + (originalY - constrainedY);
                            selectedDrawing.x = currentX;
                            selectedDrawing.y = constrainedY;
                        } else if (resizeMode === 'top-right') {
                            selectedDrawing.width = currentX - originalX;
                            selectedDrawing.height = originalHeight + (originalY - constrainedY);
                            selectedDrawing.y = constrainedY;
                        } else if (resizeMode === 'bottom-left') {
                            selectedDrawing.width = originalWidth + (originalX - currentX);
                            selectedDrawing.height = constrainedY - originalY;
                            selectedDrawing.x = currentX;
                        } else if (resizeMode === 'bottom-right') {
                            selectedDrawing.width = currentX - originalX;
                            selectedDrawing.height = constrainedY - originalY;
                        }
                    }
                } else if (selectedDrawing.type === 'text') {
                    // Text: only support dragging/moving (no resizing)
                    if (resizeMode === 'text-drag') {
                        // Calculate offset from drag start position
                        const deltaX = currentX - dragStartX;
                        const deltaY = currentY - dragStartY;
                        
                        
                        // Move text position by offset (relative to original position)
                        selectedDrawing.x += deltaX;
                        selectedDrawing.y = Math.max(toolbarHeight, selectedDrawing.y + deltaY);
                        
                        // Update drag start position for next frame
                        dragStartX = currentX;
                        dragStartY = currentY;
                    }
                }
                
                redrawCanvas();
                return;
            }
            
            // Handle regular drawing
            if (!drawingMode || !isDrawing) return;
            
            // Clear and redraw all drawings
            redrawCanvas();
            
            // Draw current drawing being created
            if (drawingMode === 'rect') {
                drawRect(startX, startY, currentX - startX, currentY - startY, currentColor, currentStrokeWidth, true);
            } else if (drawingMode === 'line') {
                drawLine(startX, startY, currentX, currentY, currentColor, currentStrokeWidth, true);
            } else if (drawingMode === 'arrow') {
                drawArrow(startX, startY, currentX, currentY, currentColor, currentStrokeWidth, true);
            } else if (drawingMode === 'text') {
                // Draw text box preview with dashed border
                drawTextBoxPreview(startX, startY, currentX - startX, currentY - startY, currentColor);
            }
        }

        function stopDrawing(e) {
            // Prevent double execution - ignore if we're not currently drawing or resizing
            if (!isDrawing && !isResizing) {
                return;
            }
            
            // Handle resize completion
            if (isResizing) {
                isResizing = false;
                resizeMode = null;
                canvas.style.cursor = 'crosshair';
                
                // Validate the resized drawing and provide feedback
                if (selectedDrawing) {
                    let isValid = true;
                    let typeName = '';
                    let wasWidthResize = resizeMode === 'width' || (resizeMode && resizeMode.startsWith('width-'));
                    
                    if (selectedDrawing.type === 'arrow' || selectedDrawing.type === 'line') {
                        typeName = selectedDrawing.type === 'arrow' ? 'Arrow' : 'Line';
                        
                        if (wasWidthResize) {
                            // Width resize feedback
                            showStatus(`✅ ${typeName} width changed to ${selectedDrawing.strokeWidth}px. Drag width handle to adjust further.`, 'success');
                        } else {
                            // Position resize validation
                            const distance = Math.sqrt(
                                (selectedDrawing.x2 - selectedDrawing.x1) ** 2 + 
                                (selectedDrawing.y2 - selectedDrawing.y1) ** 2
                            );
                            
                            if (distance < 15) {
                                showStatus(`${typeName} too small. Minimum length is 15 pixels.`, 'warning');
                                isValid = false;
                            } else {
                                showStatus(`✅ ${typeName} resized successfully. Click ${typeName.toLowerCase()} to select again.`, 'success');
                            }
                        }
                    } else if (selectedDrawing.type === 'rect') {
                        typeName = 'Rectangle';
                        
                        if (wasWidthResize) {
                            // Width resize feedback
                            showStatus(`✅ ${typeName} width changed to ${selectedDrawing.strokeWidth}px. Drag width handles to adjust further.`, 'success');
                        } else {
                            // Position resize validation
                            const minSize = 10;
                            if (Math.abs(selectedDrawing.width) < minSize || Math.abs(selectedDrawing.height) < minSize) {
                                showStatus(`${typeName} too small. Minimum size is ${minSize}x${minSize} pixels.`, 'warning');
                                isValid = false;
                            } else {
                                showStatus(`✅ ${typeName} resized successfully. Click ${typeName.toLowerCase()} to select again.`, 'success');
                            }
                        }
                    }
                }
                
                redrawCanvas();
                return;
            }
            
            if (!drawingMode || !isDrawing) return;
            
            isDrawing = false;
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            // Use current mouse position or last known position if mouse is outside window
            let endX, endY;
            if (e && e.clientX !== undefined && e.clientY !== undefined) {
                const rect = canvas.getBoundingClientRect();
                endX = Math.max(0, Math.min(canvas.width, e.clientX - rect.left));
                endY = Math.max(toolbarHeight, Math.min(canvas.height, e.clientY - rect.top));
            } else {
                // Mouse is outside window, use canvas bounds as limits
                endX = Math.max(0, Math.min(canvas.width, startX));
                endY = Math.max(toolbarHeight, Math.min(canvas.height, startY));
            }
            
            if (drawingMode === 'rect') {
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);
                
                // Only add rectangle if it has meaningful size (10px minimum)
                if (width > 10 && height > 10) {
                    drawings.push({
                        type: 'rect',
                        x: Math.min(startX, endX),
                        y: Math.min(startY, endY),
                        width: width,
                        height: height,
                        color: currentColor,
                        strokeWidth: currentStrokeWidth
                    });
                    showStatus(`✅ Rectangle added (${drawings.length} total). Ctrl+Z to undo.`, 'success');
                }
            } else if (drawingMode === 'line') {
                // Add line if it has meaningful length (10px minimum)
                const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                if (distance > 10) {
                    drawings.push({
                        type: 'line',
                        x1: startX,
                        y1: startY,
                        x2: endX,
                        y2: endY,
                        color: currentColor,
                        strokeWidth: currentStrokeWidth
                    });
                    showStatus(`✅ Line added (${drawings.length} total). Ctrl+Z to undo.`, 'success');
                }
            } else if (drawingMode === 'arrow') {
                // Add arrow if it has meaningful length (15px minimum)
                const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                if (distance > 15) {
                    drawings.push({
                        type: 'arrow',
                        x1: startX,
                        y1: startY,
                        x2: endX,
                        y2: endY,
                        color: currentColor,
                        strokeWidth: currentStrokeWidth
                    });
                    showStatus(`✅ Arrow added (${drawings.length} total). Ctrl+Z to undo.`, 'success');
                }
            } else if (drawingMode === 'text') {
                const width = Math.abs(endX - startX);
                const height = Math.abs(endY - startY);
                
                // Only create text box if it has meaningful size (30px minimum)
                if (width > 30 && height > 20) {
                    // Calculate the actual position (handle negative dimensions)
                    const textBoxX = Math.min(startX, endX);
                    const textBoxY = Math.min(startY, endY);
                    
                    // Create textarea in the drawn area
                    createTextBoxEditor(textBoxX, textBoxY, width, height);
                    showStatus('Text box created. Type your text and press Ctrl+Enter to confirm.', 'success');
                    // Don't call redrawCanvas() here to keep the text box preview visible
                    return;
                } else {
                    showStatus('Text box too small. Minimum size is 30x20 pixels.', 'warning');
                    return; // Important: return here to prevent redrawCanvas() from being called
                }
            }
            
            redrawCanvas();
        }

        function drawRect(x, y, width, height, color, strokeWidth = 3, isPreview = false) {
            ctx.strokeStyle = color;
            ctx.lineWidth = strokeWidth;
            ctx.setLineDash(isPreview ? [5, 5] : []);
            
            const rectX = width >= 0 ? x : x + width;
            const rectY = height >= 0 ? y : y + height;
            const rectWidth = Math.abs(width);
            const rectHeight = Math.abs(height);
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            // Ensure rectangle doesn't extend into toolbar area
            const clampedY = Math.max(toolbarHeight, rectY);
            const clampedHeight = Math.max(0, rectHeight - Math.max(0, toolbarHeight - rectY));
            
            // Only draw if there's a valid area below toolbar
            if (clampedHeight > 0) {
                ctx.strokeRect(rectX, clampedY, rectWidth, clampedHeight);
            }
            
            ctx.setLineDash([]);
        }
        
        function drawLine(x1, y1, x2, y2, color, strokeWidth = 3, isPreview = false) {
            ctx.strokeStyle = color;
            ctx.lineWidth = strokeWidth;
            ctx.setLineDash(isPreview ? [5, 5] : []);
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            // Clamp coordinates to avoid toolbar area
            const clampedY1 = Math.max(toolbarHeight, y1);
            const clampedY2 = Math.max(toolbarHeight, y2);
            
            ctx.beginPath();
            ctx.moveTo(x1, clampedY1);
            ctx.lineTo(x2, clampedY2);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        function drawArrow(x1, y1, x2, y2, color, strokeWidth = 3, isPreview = false) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = strokeWidth;
            ctx.setLineDash(isPreview ? [5, 5] : []);
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            // Clamp coordinates to avoid toolbar area
            const clampedY1 = Math.max(toolbarHeight, y1);
            const clampedY2 = Math.max(toolbarHeight, y2);
            
            // Draw the main arrow line
            ctx.beginPath();
            ctx.moveTo(x1, clampedY1);
            ctx.lineTo(x2, clampedY2);
            ctx.stroke();
            
            // Calculate arrow head geometry - REVERSED: arrow head points at x1,y1 (start point)
            const angle = Math.atan2(clampedY1 - clampedY2, x1 - x2); // Reversed direction
            const headLength = 20; // Length of the arrow head lines
            const headAngle = Math.PI / 6; // 30 degrees
            
            // Calculate arrow head points at the START position (x1, y1)
            const headX1 = x1 - headLength * Math.cos(angle - headAngle);
            const headY1 = clampedY1 - headLength * Math.sin(angle - headAngle);
            const headX2 = x1 - headLength * Math.cos(angle + headAngle);
            const headY2 = clampedY1 - headLength * Math.sin(angle + headAngle);
            
            // Draw filled arrow head at START position
            ctx.beginPath();
            ctx.moveTo(x1, clampedY1);
            ctx.lineTo(headX1, headY1);
            ctx.lineTo(headX2, headY2);
            ctx.closePath();
            
            if (isPreview) {
                ctx.stroke(); // Just outline for preview
            } else {
                ctx.fill(); // Filled arrow head for final
                ctx.stroke(); // Add outline for better visibility
            }
            
            ctx.setLineDash([]);
        }

        function drawTextWithBackground(drawing) {
            const { x, y, text, color, fontSize, fontFamily, bold, italic, underline, hasBackground, backgroundColor, backgroundOpacity, backgroundPadding, backgroundRadius } = drawing;
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            const clampedY = Math.max(toolbarHeight, y);
            
            // Set up text properties for measurement
            let fontStyle = '';
            if (italic) fontStyle += 'italic ';
            if (bold) fontStyle += 'bold ';
            
            ctx.font = `${fontStyle}${fontSize}px ${fontFamily || 'Arial, sans-serif'}`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';
            
            // Draw background rectangle if enabled
            if (hasBackground) {
                const lines = text.split('\n');
                const textWidth = drawing.width || getTextWidth(text);
                const textHeight = drawing.height || getTextHeight(text);
                const padding = backgroundPadding || 8;
                
                // Save current state
                const originalGlobalAlpha = ctx.globalAlpha;
                
                // Set background opacity
                ctx.globalAlpha = (backgroundOpacity || 80) / 100;
                
                // Draw background rectangle (with rounded corners if specified)
                ctx.fillStyle = backgroundColor || '#ffffff';
                const radius = backgroundRadius || 4;
                
                if (radius > 0 && ctx.roundRect) {
                    // Draw rounded rectangle
                    const rectX = x - padding;
                    const rectY = clampedY - padding;
                    const rectWidth = textWidth + (padding * 2);
                    const rectHeight = textHeight + (padding * 2);
                    
                    ctx.beginPath();
                    ctx.roundRect(rectX, rectY, rectWidth, rectHeight, radius);
                    ctx.fill();
                } else if (radius > 0) {
                    // Fallback for browsers without roundRect - use manual rounded corners
                    const rectX = x - padding;
                    const rectY = clampedY - padding;
                    const rectWidth = textWidth + (padding * 2);
                    const rectHeight = textHeight + (padding * 2);
                    
                    ctx.beginPath();
                    ctx.moveTo(rectX + radius, rectY);
                    ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + rectHeight, radius);
                    ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX, rectY + rectHeight, radius);
                    ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY, radius);
                    ctx.arcTo(rectX, rectY, rectX + rectWidth, rectY, radius);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Draw regular rectangle
                    ctx.fillRect(
                        x - padding, 
                        clampedY - padding, 
                        textWidth + (padding * 2), 
                        textHeight + (padding * 2)
                    );
                }
                
                // Restore alpha for text
                ctx.globalAlpha = originalGlobalAlpha;
            }
            
            // Draw text on top of background
            ctx.fillStyle = color;
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                const lineY = clampedY + (index * fontSize * 1.2);
                ctx.fillText(line, x, lineY);
                
                // Draw underline if enabled
                if (underline) {
                    const lineWidth = ctx.measureText(line).width;
                    const underlineY = lineY + fontSize + 2; // Slight offset below text
                    ctx.beginPath();
                    ctx.moveTo(x, underlineY);
                    ctx.lineTo(x + lineWidth, underlineY);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = Math.max(1, fontSize / 16); // Scale line width with font size
                    ctx.stroke();
                }
            });
        }

        function updateTextEditorBackground() {
            if (activeTextEditor) {
                if (currentBackgroundEnabled) {
                    // Convert hex color to rgba with opacity
                    const hex = currentBackgroundColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    const alpha = currentBackgroundOpacity / 100;
                    activeTextEditor.style.background = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                } else {
                    // Default transparent background
                    activeTextEditor.style.background = 'rgba(255, 255, 255, 0.1)';
                }
            }
        }

        function handleTextEditorKeydown(e) {
            if (e.key === 'Escape') {
                e.preventDefault();
                cancelTextEditing();
            } else if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                finishTextEditing();
            }
            // Allow normal typing and Enter for new lines
        }

        function handleDocumentClick(e) {
            // If there's no active text editor, ignore
            if (!activeTextEditor) {
                return;
            }
            
            // If click is on the text editor itself, ignore
            if (activeTextEditor.contains(e.target)) {
                return;
            }
            
            // Remove this event handler and finish text editing
            document.removeEventListener('click', handleDocumentClick, { capture: true });
            finishTextEditing();
        }

        function finishTextEditing() {
            if (!activeTextEditor) return;
            
            const text = activeTextEditor.value.trim();
            if (text) {
                const canvasX = parseFloat(activeTextEditor.dataset.canvasX);
                const canvasY = parseFloat(activeTextEditor.dataset.canvasY);
                
                // Create text drawing object
                const textDrawing = {
                    type: 'text',
                    x: canvasX,
                    y: canvasY,
                    text: text,
                    color: currentColor,
                    fontSize: currentFontSize,
                    fontFamily: currentFontFamily,
                    bold: currentBold,
                    italic: currentItalic,
                    underline: currentUnderline,
                    width: getTextWidth(text, currentFontSize, currentFontFamily),
                    height: getTextHeight(text, currentFontSize),
                    // Background properties
                    hasBackground: currentBackgroundEnabled,
                    backgroundColor: currentBackgroundColor,
                    backgroundOpacity: currentBackgroundOpacity,
                    backgroundPadding: 8 // Default padding around text for consistency
                };
                
                // Add to drawings array
                drawings.push(textDrawing);
                redrawCanvas();
                
                showStatus(`Text added: "${text.length > 20 ? text.substring(0, 20) + '...' : text}"`);
            }
            
            // Clean up
            cleanupTextEditor();
        }

        function cancelTextEditing() {
            if (activeTextEditor) {
                cleanupTextEditor();
            }
        }

        function cleanupTextEditor() {
            if (activeTextEditor) {
                activeTextEditor.removeEventListener('keydown', handleTextEditorKeydown);
                document.removeEventListener('click', handleDocumentClick, { capture: true });
                document.body.removeChild(activeTextEditor);
                activeTextEditor = null;
            }
            // Clear the active text box
            activeTextBox = null;
            isTypingText = false;
            // Redraw canvas to remove text box preview
            redrawCanvas();
        }

        function createTextBoxEditor(canvasX, canvasY, width, height) {
            // Prevent multiple text editors
            if (activeTextEditor) {
                finishTextEditing();
            }
            
            // Reset background to disabled for new text
            currentBackgroundEnabled = false;
            if (bgEnableCheckbox) {
                bgEnableCheckbox.checked = false;
                // Also disable the color options
                const colorOptions = document.querySelector('.background-color-options');
                if (colorOptions) {
                    colorOptions.classList.add('disabled');
                }
            }
            
            // Store the text box area for drawing
            activeTextBox = {
                x: canvasX,
                y: canvasY,
                width: width,
                height: height,
                color: currentColor
            };
            
            // Get canvas position for proper positioning
            const canvasRect = canvas.getBoundingClientRect();
            
            // Create transparent textarea overlay
            activeTextEditor = document.createElement('textarea');
            activeTextEditor.style.position = 'absolute';
            activeTextEditor.style.left = (canvasRect.left + canvasX) + 'px';
            activeTextEditor.style.top = (canvasRect.top + canvasY) + 'px';
            activeTextEditor.style.width = width + 'px';
            activeTextEditor.style.height = height + 'px';
            activeTextEditor.style.fontSize = currentFontSize + 'px';
            activeTextEditor.style.fontFamily = currentFontFamily;
            activeTextEditor.style.fontWeight = currentBold ? 'bold' : 'normal';
            activeTextEditor.style.fontStyle = currentItalic ? 'italic' : 'normal';
            activeTextEditor.style.textDecoration = currentUnderline ? 'underline' : 'none';
            activeTextEditor.style.color = currentColor;
            // Set background based on current background settings
            updateTextEditorBackground();
            activeTextEditor.style.border = '2px dashed ' + currentColor;
            activeTextEditor.style.borderRadius = '4px';
            activeTextEditor.style.padding = '8px';
            activeTextEditor.style.resize = 'none';
            activeTextEditor.style.zIndex = '9999';
            activeTextEditor.style.outline = 'none';
            activeTextEditor.style.overflow = 'auto'; // Allow scrolling for long text
            activeTextEditor.placeholder = 'Type your text here...';
            
            // Store position for the drawing - adjust for border (2px) and padding (8px) offset
            // This ensures text appears exactly where user clicked, not offset by border/padding
            const borderOffset = 2;
            const paddingOffset = 8;
            const totalXOffset = borderOffset + paddingOffset; // 10px total horizontal offset
            
            // For Y position, we need additional adjustment because textarea text baseline
            // doesn't exactly match canvas textBaseline = 'top'
            // Add a small font-size dependent offset to account for baseline differences
            const baselineOffset = Math.round(currentFontSize * 0.1); // ~10% of font size
            const totalYOffset = borderOffset + paddingOffset + baselineOffset;
            
            activeTextEditor.dataset.canvasX = canvasX + totalXOffset;
            activeTextEditor.dataset.canvasY = canvasY + totalYOffset;
            
            // Add to document body for proper positioning
            document.body.appendChild(activeTextEditor);
            
            // Focus and enable text input mode
            isTypingText = true;
            
            // Use setTimeout to ensure proper focus after DOM manipulation
            setTimeout(() => {
                if (activeTextEditor) {
                    activeTextEditor.focus();
                    activeTextEditor.select(); // Select all placeholder text if any
                }
            }, 10);
            
            // Add event handlers
            activeTextEditor.addEventListener('keydown', handleTextEditorKeydown);
            
            // Add document click handler after a small delay to prevent interference with the creating click
            setTimeout(() => {
                document.addEventListener('click', handleDocumentClick, { capture: true });
            }, 100);
        }

        function getTextWidth(text, fontSize = currentFontSize, fontFamily = currentFontFamily, bold = currentBold, italic = currentItalic) {
            // Build font string with style modifiers
            let fontStyle = '';
            if (italic) fontStyle += 'italic ';
            if (bold) fontStyle += 'bold ';
            
            ctx.font = `${fontStyle}${fontSize}px ${fontFamily}`;
            const lines = text.split('\n');
            let maxWidth = 0;
            lines.forEach(line => {
                const width = ctx.measureText(line).width;
                if (width > maxWidth) maxWidth = width;
            });
            return maxWidth;
        }

        function getTextHeight(text, fontSize = currentFontSize) {
            const lines = text.split('\n');
            return lines.length * fontSize * 1.2; // 1.2 for line spacing
        }

        function drawTextBoxPreview(x, y, width, height, color) {
            // Draw dashed border rectangle to show text box area
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]); // Dashed line pattern
            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]); // Reset line dash
        }

        function drawTextSelectionBorder(drawing) {
            const { x, y, text, fontSize, hasBackground, backgroundPadding } = drawing;
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            const clampedY = Math.max(toolbarHeight, y);
            
            // Calculate text dimensions
            const textWidth = drawing.width || getTextWidth(text, fontSize);
            const textHeight = drawing.height || getTextHeight(text, fontSize);
            // Use extra padding for selection border to accommodate bold text sizing changes
            const padding = 12;
            
            // Theme-aware border color
            const borderColor = effectiveTheme === 'dark' ? '#ffffff' : '#000000';
            
            // Draw thin dashed border around text area
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1; // Thinner border
            ctx.setLineDash([4, 2]); // Smaller dashed line pattern
            
            // Center the text within the boundary by calculating proper positioning
            const borderX = x - padding;
            const borderY = clampedY - padding;
            const borderWidth = textWidth + (padding * 2);
            const borderHeight = textHeight + (padding * 2);
            
            ctx.strokeRect(borderX, borderY, borderWidth, borderHeight);
            ctx.setLineDash([]); // Reset line dash
        }



        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get toolbar height to filter out drawings in toolbar area
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            drawings.forEach(drawing => {
                if (drawing.type === 'rect') {
                    // Only draw rectangles that don't start in toolbar area
                    if (drawing.y >= toolbarHeight) {
                        drawRect(drawing.x, drawing.y, drawing.width, drawing.height, drawing.color, drawing.strokeWidth || 3);
                    }
                } else if (drawing.type === 'line') {
                    // Only draw lines that don't start in toolbar area
                    if (drawing.y1 >= toolbarHeight || drawing.y2 >= toolbarHeight) {
                        drawLine(drawing.x1, drawing.y1, drawing.x2, drawing.y2, drawing.color, drawing.strokeWidth || 3);
                    }
                } else if (drawing.type === 'arrow') {
                    // Only draw arrows that don't start in toolbar area
                    if (drawing.y1 >= toolbarHeight || drawing.y2 >= toolbarHeight) {
                        drawArrow(drawing.x1, drawing.y1, drawing.x2, drawing.y2, drawing.color, drawing.strokeWidth || 3);
                    }
                } else if (drawing.type === 'text') {
                    // Only draw text that doesn't overlap with toolbar area
                    if (drawing.y >= toolbarHeight) {
                        drawTextWithBackground(drawing);
                        
                        // Draw dashed border if this text is selected
                        if (selectedDrawing === drawing) {
                            drawTextSelectionBorder(drawing);
                        }
                    }
                }
                
                // Draw resize handles if this drawing is selected (for all drawing types)
                if (selectedDrawing === drawing) {
                    drawResizeHandles(drawing);
                }
            });
            
            // Draw active text box if there is one
            if (activeTextBox) {
                drawTextBoxPreview(activeTextBox.x, activeTextBox.y, activeTextBox.width, activeTextBox.height, activeTextBox.color);
            }
        }
        
        function drawResizeHandles(drawing) {
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#0066cc';
            ctx.lineWidth = 2;
            
            if (drawing.type === 'arrow' || drawing.type === 'line') {
                // Linear drawings: two handles at start and end points, plus width handle at midpoint
                const clampedY1 = Math.max(toolbarHeight, drawing.y1);
                const clampedY2 = Math.max(toolbarHeight, drawing.y2);
                
                // Draw handle at start point (position resize)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#0066cc';
                ctx.beginPath();
                ctx.arc(drawing.x1, clampedY1, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Draw handle at end point (position resize)
                ctx.beginPath();
                ctx.arc(drawing.x2, clampedY2, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Draw width handle at midpoint (perpendicular to line)
                const midX = (drawing.x1 + drawing.x2) / 2;
                const midY = Math.max(toolbarHeight, (drawing.y1 + drawing.y2) / 2);
                
                // Calculate perpendicular offset for width handle
                const lineLength = Math.sqrt((drawing.x2 - drawing.x1) ** 2 + (drawing.y2 - drawing.y1) ** 2);
                if (lineLength > 0) {
                    const perpX = -(drawing.y2 - drawing.y1) / lineLength;
                    const perpY = (drawing.x2 - drawing.x1) / lineLength;
                    const offset = 15; // Distance from line
                    
                    const widthHandleX = midX + perpX * offset;
                    const widthHandleY = midY + perpY * offset;
                    
                    // Draw width handle (different style)
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.9)'; // Gold color for width handle
                    ctx.strokeStyle = '#ff8c00';
                    ctx.beginPath();
                    ctx.rect(widthHandleX - resizeHandleRadius/2, widthHandleY - resizeHandleRadius/2, 
                           resizeHandleRadius, resizeHandleRadius);
                    ctx.fill();
                    ctx.stroke();
                }
                
            } else if (drawing.type === 'rect') {
                // Rectangle: handles at all four corners plus width handles on edges
                const clampedY1 = Math.max(toolbarHeight, drawing.y);
                const clampedY2 = Math.max(toolbarHeight, drawing.y + drawing.height);
                
                // Corner handles (position resize) - White circles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#0066cc';
                
                // Top-left handle
                ctx.beginPath();
                ctx.arc(drawing.x, clampedY1, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Top-right handle
                ctx.beginPath();
                ctx.arc(drawing.x + drawing.width, clampedY1, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Bottom-left handle
                ctx.beginPath();
                ctx.arc(drawing.x, clampedY2, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Bottom-right handle
                ctx.beginPath();
                ctx.arc(drawing.x + drawing.width, clampedY2, resizeHandleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Width handles on edges (stroke width adjustment) - Gold squares
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.strokeStyle = '#ff8c00';
                
                const midY = Math.max(toolbarHeight, drawing.y + drawing.height / 2);
                const midX = drawing.x + drawing.width / 2;
                
                // Left edge width handle
                ctx.beginPath();
                ctx.rect(drawing.x - 8 - resizeHandleRadius/2, midY - resizeHandleRadius/2, 
                        resizeHandleRadius, resizeHandleRadius);
                ctx.fill();
                ctx.stroke();
                
                // Right edge width handle
                ctx.beginPath();
                ctx.rect(drawing.x + drawing.width + 8 - resizeHandleRadius/2, midY - resizeHandleRadius/2, 
                        resizeHandleRadius, resizeHandleRadius);
                ctx.fill();
                ctx.stroke();
                
                // Top edge width handle
                ctx.beginPath();
                ctx.rect(midX - resizeHandleRadius/2, clampedY1 - 8 - resizeHandleRadius/2, 
                        resizeHandleRadius, resizeHandleRadius);
                ctx.fill();
                ctx.stroke();
                
                // Bottom edge width handle
                ctx.beginPath();
                ctx.rect(midX - resizeHandleRadius/2, clampedY2 + 8 - resizeHandleRadius/2, 
                        resizeHandleRadius, resizeHandleRadius);
                ctx.fill();
                ctx.stroke();
            } else if (drawing.type === 'text') {
                // Text: No additional border needed - drawTextSelectionBorder handles text selection visualization
                // Entire text area is draggable like Inkscape without additional visual handles
            }
        }
        
        function getDistanceToPoint(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        function getDistanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return getDistanceToPoint(px, py, x1, y1);
            
            const param = dot / lenSq;
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            return getDistanceToPoint(px, py, xx, yy);
        }
        
        function findDrawingAtPoint(x, y) {
            // Check in reverse order (top drawings first)
            for (let i = drawings.length - 1; i >= 0; i--) {
                const drawing = drawings[i];
                
                if (drawing.type === 'arrow' || drawing.type === 'line') {
                    // Check if click is near the line/arrow
                    const distanceToLine = getDistanceToLine(x, y, drawing.x1, drawing.y1, drawing.x2, drawing.y2);
                    if (distanceToLine <= 8) { // 8px tolerance for clicking on line/arrow
                        return drawing;
                    }
                } else if (drawing.type === 'rect') {
                    // Check if click is within rectangle bounds (including border area)
                    const tolerance = 8;
                    if (x >= drawing.x - tolerance && 
                        x <= drawing.x + drawing.width + tolerance &&
                        y >= drawing.y - tolerance && 
                        y <= drawing.y + drawing.height + tolerance) {
                        
                        // Check if it's near the border (not filled center)
                        if (x <= drawing.x + tolerance || 
                            x >= drawing.x + drawing.width - tolerance ||
                            y <= drawing.y + tolerance || 
                            y >= drawing.y + drawing.height - tolerance) {
                            return drawing;
                        }
                    }
                } else if (drawing.type === 'text') {
                    // Check if click is within text bounds
                    const textWidth = drawing.width || 100; // Use calculated width or fallback
                    // Use proper text height calculation including background padding if present
                    const textHeight = drawing.height || (drawing.fontSize * 1.2); // Line height calculation
                    const tolerance = drawing.hasBackground ? 8 : 4; // Larger tolerance for text with background
                    
                    if (x >= drawing.x - tolerance && 
                        x <= drawing.x + textWidth + tolerance &&
                        y >= drawing.y - tolerance && 
                        y <= drawing.y + textHeight + tolerance) {
                        return drawing;
                    }
                }
            }
            return null;
        }
        
        function getResizeHandleAtPoint(x, y, drawing) {
            if (!drawing) return null;
            
            // Get toolbar height to avoid drawing over it
            const toolbar = document.querySelector('.top-toolbar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight : 48;
            const handleTolerance = resizeHandleRadius + 2;
            
            if (drawing.type === 'arrow' || drawing.type === 'line') {
                // Linear drawings: check start and end handles, plus width handle
                const clampedY1 = Math.max(toolbarHeight, drawing.y1);
                const clampedY2 = Math.max(toolbarHeight, drawing.y2);
                
                // Check width handle at midpoint first (higher priority)
                const midX = (drawing.x1 + drawing.x2) / 2;
                const midY = Math.max(toolbarHeight, (drawing.y1 + drawing.y2) / 2);
                const lineLength = Math.sqrt((drawing.x2 - drawing.x1) ** 2 + (drawing.y2 - drawing.y1) ** 2);
                
                if (lineLength > 0) {
                    const perpX = -(drawing.y2 - drawing.y1) / lineLength;
                    const perpY = (drawing.x2 - drawing.x1) / lineLength;
                    const offset = 15;
                    const widthHandleX = midX + perpX * offset;
                    const widthHandleY = midY + perpY * offset;
                    
                    if (getDistanceToPoint(x, y, widthHandleX, widthHandleY) <= handleTolerance) {
                        return 'width';
                    }
                }
                
                // Check start handle
                if (getDistanceToPoint(x, y, drawing.x1, clampedY1) <= handleTolerance) {
                    return 'start';
                }
                
                // Check end handle
                if (getDistanceToPoint(x, y, drawing.x2, clampedY2) <= handleTolerance) {
                    return 'end';
                }
                
            } else if (drawing.type === 'rect') {
                // Rectangle: check width handles first (higher priority), then corner handles
                const clampedY1 = Math.max(toolbarHeight, drawing.y);
                const clampedY2 = Math.max(toolbarHeight, drawing.y + drawing.height);
                const midY = Math.max(toolbarHeight, drawing.y + drawing.height / 2);
                const midX = drawing.x + drawing.width / 2;
                
                // Check width handles first
                // Left edge width handle
                if (getDistanceToPoint(x, y, drawing.x - 8, midY) <= handleTolerance) {
                    return 'width-left';
                }
                
                // Right edge width handle
                if (getDistanceToPoint(x, y, drawing.x + drawing.width + 8, midY) <= handleTolerance) {
                    return 'width-right';
                }
                
                // Top edge width handle
                if (getDistanceToPoint(x, y, midX, clampedY1 - 8) <= handleTolerance) {
                    return 'width-top';
                }
                
                // Bottom edge width handle
                if (getDistanceToPoint(x, y, midX, clampedY2 + 8) <= handleTolerance) {
                    return 'width-bottom';
                }
                
                // Corner handles (position resize)
                // Top-left handle
                if (getDistanceToPoint(x, y, drawing.x, clampedY1) <= handleTolerance) {
                    return 'top-left';
                }
                
                // Top-right handle
                if (getDistanceToPoint(x, y, drawing.x + drawing.width, clampedY1) <= handleTolerance) {
                    return 'top-right';
                }
                
                // Bottom-left handle
                if (getDistanceToPoint(x, y, drawing.x, clampedY2) <= handleTolerance) {
                    return 'bottom-left';
                }
                
                // Bottom-right handle
                if (getDistanceToPoint(x, y, drawing.x + drawing.width, clampedY2) <= handleTolerance) {
                    return 'bottom-right';
                }
            }
            
            return null;
        }

        function clearAllDrawings() {
            drawings = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            showStatus('All drawings cleared');
        }

        function undoLastDrawing() {
            if (drawings.length > 0) {
                const removed = drawings.pop();
                redrawCanvas();
                showStatus(`${removed.type} removed (${drawings.length} remaining)`);
            } else {
                showStatus('No drawings to undo');
            }
        }
        
        function adjustStrokeWidth(direction) {
            // Adjust global stroke width
            const oldWidth = currentStrokeWidth;
            currentStrokeWidth = Math.max(1, Math.min(20, currentStrokeWidth + direction));
            
            // Update UI indicator
            borderWidthIndicator.textContent = `${currentStrokeWidth}px`;
            
            // Update dropdown selection
            borderWidthDropdown.querySelectorAll('.width-option').forEach(option => {
                option.classList.remove('selected');
                if (parseInt(option.dataset.width) === currentStrokeWidth) {
                    option.classList.add('selected');
                }
            });
            
            // Animate indicator
            borderWidthIndicator.style.transform = 'scale(1.3)';
            setTimeout(() => {
                borderWidthIndicator.style.transform = 'scale(1)';
            }, 200);
            
            // Also adjust selected drawing's width if any
            if (selectedDrawing) {
                selectedDrawing.strokeWidth = currentStrokeWidth;
                redrawCanvas();
                showStatus(`✅ Width changed to ${currentStrokeWidth}px. Selected drawing updated.`, 'success');
            } else {
                showStatus(`Width changed to ${currentStrokeWidth}px. New drawings will use this width.`, 'success');
            }
        }

        function scaleBordersOnResize() {
            if (!lastImageRect || drawings.length === 0 || !screenshotImage) return;
            
            const currentImageRect = screenshotImage.getBoundingClientRect();
            
            // Calculate scaling factors
            const scaleX = currentImageRect.width / lastImageRect.width;
            const scaleY = currentImageRect.height / lastImageRect.height;
            const offsetX = currentImageRect.left - lastImageRect.left;
            const offsetY = currentImageRect.top - lastImageRect.top;
            
            // Scale all existing drawings
            drawings.forEach(drawing => {
                if (drawing.type === 'rect' || drawing.type === 'text') {
                    // Rectangle and text have x, y, width, height properties
                    const relativeX = drawing.x - lastImageRect.left;
                    const relativeY = drawing.y - lastImageRect.top;
                    
                    // Apply scaling and new offset
                    drawing.x = currentImageRect.left + (relativeX * scaleX);
                    drawing.y = currentImageRect.top + (relativeY * scaleY);
                    
                    if (drawing.width) drawing.width = drawing.width * scaleX;
                    if (drawing.height) drawing.height = drawing.height * scaleY;
                } else if (drawing.type === 'line' || drawing.type === 'arrow') {
                    // Lines and arrows have x1, y1, x2, y2 properties
                    const relativeX1 = drawing.x1 - lastImageRect.left;
                    const relativeY1 = drawing.y1 - lastImageRect.top;
                    const relativeX2 = drawing.x2 - lastImageRect.left;
                    const relativeY2 = drawing.y2 - lastImageRect.top;
                    
                    // Apply scaling and new offset
                    drawing.x1 = currentImageRect.left + (relativeX1 * scaleX);
                    drawing.y1 = currentImageRect.top + (relativeY1 * scaleY);
                    drawing.x2 = currentImageRect.left + (relativeX2 * scaleX);
                    drawing.y2 = currentImageRect.top + (relativeY2 * scaleY);
                }
            });
            
            // Update last known image position
            lastImageRect = currentImageRect;
        }
    </script>
</body>
</html>